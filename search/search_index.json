{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prueba de placas, shield y sensores para Arduino \u00b6 Se realizar\u00e1 an\u00e1lisis y pruebas b\u00e1sicas de diferentes placas, sensores y escudos con exposici\u00f3n de resultados. Las placas controladoras que m\u00e1s utilizar\u00e9 son las de las im\u00e1genes, aunque tambi\u00e9n se ver\u00e1n y analizar\u00e1n otras de esta marca, de otras marcas y originales. Con pines extendidos Easy Plug","title":"Introducci\u00f3n"},{"location":"#prueba-de-placas-shield-y-sensores-para-arduino","text":"Se realizar\u00e1 an\u00e1lisis y pruebas b\u00e1sicas de diferentes placas, sensores y escudos con exposici\u00f3n de resultados. Las placas controladoras que m\u00e1s utilizar\u00e9 son las de las im\u00e1genes, aunque tambi\u00e9n se ver\u00e1n y analizar\u00e1n otras de esta marca, de otras marcas y originales. Con pines extendidos Easy Plug","title":"Prueba de placas, shield y sensores para Arduino"},{"location":"ESP01/","text":"Modulo ESP8266 ESP 01, shield de programaci\u00f3n y direcci\u00f3n MAC \u00b6 M\u00f3dulo ESP8266 ESP 01 \u00b6 Introducci\u00f3n \u00b6 El m\u00f3dulo Wifi seleccionado (ESP-01) es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a un Arduino UNO, con el \u00fanico fin de darle conectividad Wifi. Es este motivo por el que se ha considerado este modelo concreto el id\u00f3neo para llevar a cabo el proyecto aqu\u00ed expuesto, ya que no necesitamos m\u00e1s pines extra, ni otro tipo de ventajas que incluyen modelos superiores. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (los veremos a continuaci\u00f3n) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa de control del proyecto y el ESP8266, consiguiendo as\u00ed conectar a una red WIFI y dar un primer paso de gigantes en el mundo IoT. Caracter\u00edsticas \u00b6 El aspecto del ESP-01 y algunas de sus caracter\u00edsticas los vemos a continuaci\u00f3n. Aspecto del ESP-01 ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. La memoria flash es la BG25Q80A. Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). La antena WiFi para la conexi\u00f3n a internet est\u00e1 dise\u00f1ada en la placa. Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante. A continuaci\u00f3n vemos la imagen con la distribuci\u00f3n de pines y su significado: Distribuci\u00f3n de pines en el ESP-01 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. Datos obtenidos de programarfacil . *GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.* Programaci\u00f3n del m\u00f3dulo ESP8266 ESP 01 \u00b6 El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que normalmente estamos acostumbrados dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que, por ejemplo, en el entorno ArduinoBlocks el mismo ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines: GPIO0 = 0 (nivel bajo o LOW = 0 V) GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino, que no vamos a explicar aqu\u00ed, o por medio de un convertidor USB-serie igual o similar al KS0388 Keyestudio USB to ESP-01S Wifi Module Serial Port Shield de la imagen. Shield para el m\u00f3dulo WiFi ESP-01 Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar. Comando AT en el ESP8266 \u00b6 El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. Preparaci\u00f3n del m\u00f3dulo ESP-01 \u00b6 Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo Wi-fi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo Wi-fi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Conexi\u00f3n y configuraci\u00f3n de la consola Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Conexi\u00f3n correcta Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Cambio del baudrate a 9600 Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Obtener la direcci\u00f3n MAC del ESP-01 \u00b6 Introducci\u00f3n \u00b6 Pretendemos averiguar la direcci\u00f3n fisica o MAC de un dispositivo de conexi\u00f3n WiFi y para ello vamos a seguir unos sencillo pasos, uqe si los ejecutamos en el orden correcto nos dar\u00e1n el resultado esperado. Yo lo voy a hacer sobre una placa Keyestudio UNO, pero el procedimiento puede ser v\u00e1lido para otros modelos de placa. Firmware \u00b6 Antes de conectar nada a nuestra placa vamos a cargar un programa vac\u00edo en el IDE de arduino y grabarlo en la placa Keyestudio UNO. void setup() { // put your setup code here, to run once: } void loop() { // put your main code here, to run repeatedly: } Conexionado \u00b6 Ahora procedemos a conectar nuestro ESP8266 ESP01 para poder comunicar nuestro ordenador con el ESP8266. El esquema es el que vemos en la imagen siguiente: Conexionado ESP-01 y UNO Comunicaci\u00f3n entre PC y ESP01 \u00b6 Con un programa vac\u00edo en nuestra placa Keyestudio UNO y las conexiones descritas en realidad lo que hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n inicial Escribimos AT y pulsamos Enter o clicamos en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responer\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Conexi\u00f3n correcta Direcci\u00f3n MAC \u00b6 El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es el que vemos en la imagen siguiente: Comando para obtener la MAC El comando AT+CIFSR nos devuelve el siguiente resultado: Respuesta al comando comando AT+CIFSR","title":"Modulo ESP8266 ESP 01, shield de programaci\u00f3n y direcci\u00f3n MAC"},{"location":"ESP01/#modulo-esp8266-esp-01-shield-de-programacion-y-direccion-mac","text":"","title":"Modulo ESP8266 ESP 01, shield de programaci\u00f3n y direcci\u00f3n MAC"},{"location":"ESP01/#modulo-esp8266-esp-01","text":"","title":"M\u00f3dulo ESP8266 ESP 01"},{"location":"ESP01/#introduccion","text":"El m\u00f3dulo Wifi seleccionado (ESP-01) es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a un Arduino UNO, con el \u00fanico fin de darle conectividad Wifi. Es este motivo por el que se ha considerado este modelo concreto el id\u00f3neo para llevar a cabo el proyecto aqu\u00ed expuesto, ya que no necesitamos m\u00e1s pines extra, ni otro tipo de ventajas que incluyen modelos superiores. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (los veremos a continuaci\u00f3n) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa de control del proyecto y el ESP8266, consiguiendo as\u00ed conectar a una red WIFI y dar un primer paso de gigantes en el mundo IoT.","title":"Introducci\u00f3n"},{"location":"ESP01/#caracteristicas","text":"El aspecto del ESP-01 y algunas de sus caracter\u00edsticas los vemos a continuaci\u00f3n. Aspecto del ESP-01 ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. La memoria flash es la BG25Q80A. Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). La antena WiFi para la conexi\u00f3n a internet est\u00e1 dise\u00f1ada en la placa. Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante. A continuaci\u00f3n vemos la imagen con la distribuci\u00f3n de pines y su significado: Distribuci\u00f3n de pines en el ESP-01 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. Datos obtenidos de programarfacil . *GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.*","title":"Caracter\u00edsticas"},{"location":"ESP01/#programacion-del-modulo-esp8266-esp-01","text":"El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que normalmente estamos acostumbrados dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que, por ejemplo, en el entorno ArduinoBlocks el mismo ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines: GPIO0 = 0 (nivel bajo o LOW = 0 V) GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino, que no vamos a explicar aqu\u00ed, o por medio de un convertidor USB-serie igual o similar al KS0388 Keyestudio USB to ESP-01S Wifi Module Serial Port Shield de la imagen. Shield para el m\u00f3dulo WiFi ESP-01 Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.","title":"Programaci\u00f3n del m\u00f3dulo ESP8266 ESP 01"},{"location":"ESP01/#comando-at-en-el-esp8266","text":"El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266.","title":"Comando AT en el ESP8266"},{"location":"ESP01/#preparacion-del-modulo-esp-01","text":"Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo Wi-fi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo Wi-fi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Conexi\u00f3n y configuraci\u00f3n de la consola Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Conexi\u00f3n correcta Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Cambio del baudrate a 9600 Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo.","title":"Preparaci\u00f3n del m\u00f3dulo ESP-01"},{"location":"ESP01/#obtener-la-direccion-mac-del-esp-01","text":"","title":"Obtener la direcci\u00f3n MAC del ESP-01"},{"location":"ESP01/#introduccion_1","text":"Pretendemos averiguar la direcci\u00f3n fisica o MAC de un dispositivo de conexi\u00f3n WiFi y para ello vamos a seguir unos sencillo pasos, uqe si los ejecutamos en el orden correcto nos dar\u00e1n el resultado esperado. Yo lo voy a hacer sobre una placa Keyestudio UNO, pero el procedimiento puede ser v\u00e1lido para otros modelos de placa.","title":"Introducci\u00f3n"},{"location":"ESP01/#firmware","text":"Antes de conectar nada a nuestra placa vamos a cargar un programa vac\u00edo en el IDE de arduino y grabarlo en la placa Keyestudio UNO. void setup() { // put your setup code here, to run once: } void loop() { // put your main code here, to run repeatedly: }","title":"Firmware"},{"location":"ESP01/#conexionado","text":"Ahora procedemos a conectar nuestro ESP8266 ESP01 para poder comunicar nuestro ordenador con el ESP8266. El esquema es el que vemos en la imagen siguiente: Conexionado ESP-01 y UNO","title":"Conexionado"},{"location":"ESP01/#comunicacion-entre-pc-y-esp01","text":"Con un programa vac\u00edo en nuestra placa Keyestudio UNO y las conexiones descritas en realidad lo que hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n inicial Escribimos AT y pulsamos Enter o clicamos en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responer\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Conexi\u00f3n correcta","title":"Comunicaci\u00f3n entre PC y ESP01"},{"location":"ESP01/#direccion-mac","text":"El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es el que vemos en la imagen siguiente: Comando para obtener la MAC El comando AT+CIFSR nos devuelve el siguiente resultado: Respuesta al comando comando AT+CIFSR","title":"Direcci\u00f3n MAC"},{"location":"ccs811/","text":"Sensor CCS811 de eCO2, TVOC y temperatura \u00b6 Descripci\u00f3n \u00b6 El sensor mide par\u00e1metros de calidad del aire y utiliza el chip CCS811B. Es un peque\u00f1o sensor de gas digital de muy bajo consumo que puede detectar una amplia gama de compuestos org\u00e1nicos vol\u00e1tiles, incluidos los niveles equivalentes de di\u00f3xido de carbono (eCO2) y \u00f3xido met\u00e1lico (MOX). La respuesta del sensor al di\u00f3xido de carbono equivalente (eCO2) se mide en el rango de 400 a 8192 ppm, y otros compuestos org\u00e1nicos vol\u00e1tiles (TVOC, del ingl\u00e9s Volatile Organic Compound) var\u00edan de 0 a 1187 ppb. El sensor tambi\u00e9n cuenta con un termistor de precisi\u00f3n de 10K 1% tipo NTC, que se puede utilizar para medir la temperatura. Si queremos aprender mas sobre los VOC podemos hacerlo en el enlace Compuestos org\u00e1nicos vol\u00e1tiles pero al menos debemos saber que son liberados al quemar combustibles como gasolina, madera, carb\u00f3n o gas natural y que tambi\u00e9n son liberados por disolventes, pinturas y otros productos empleados y almacenados en la casa y el lugar de trabajo. Algunos ejemplos de compuestos org\u00e1nicos vol\u00e1tiles son: Naturales: isopreno, pineno y limoneno Artificiales: benceno, tolueno, nitrobenceno Otros ejemplos: formaldeh\u00eddo, clorobenceno, disolventes como tolueno, xileno, acetona y tetracloroetileno. En la wiki del enlace tenemos toda la informaci\u00f3n original del sensor KS0457 CCS811 de keyestudio que tiene el aspecto de la imagen siguiente: Aspecto del sensor CCS811 Especificaciones \u00b6 Tensi\u00f3n de alimentaci\u00f3n: 5V DC Consumo: 30mA Potencia m\u00e1xima: 46mW Rango de medida eCO2: 400-8192 ppm Rango de medida TVOC: 0 to 1187 ppb Temperatura de trabajo: -25 ~ +65\u2103 Distribuci\u00f3n de patillas \u00b6 En la imagen siguiente vemos el pinout del dispositivo. Pinout del sensor CCS811 Conexionado \u00b6 El conexionado b\u00e1sico del sensor lo vemos en la imagen siguiente que ha sido extraida de su wiki. Conexionado del sensor CCS811 Prueba del sensor CCS811 \u00b6 Librer\u00eda \u00b6 Para poder trabajar con este sensor necesitamos descargarnos e instalar la librer\u00eda Adafruit CCS811 que est\u00e1 disponible en el enlace. Si necesitas saber mas sobre librer\u00edas en Arduino u otras muchas cosas te recomiendo visitar la web de Luis del Valle Programarfacil y en concreto la entrada del blog C\u00f3mo instalar una librer\u00eda de Arduino en el entorno de desarrollo para aprender todo sobre las librer\u00edas. La propia librer\u00eda incluye dos ejemplos de uso y en base a ellos vamos a desarrollar el c\u00f3digo para la prueba del sensor. Prueba inicial \u00b6 Vamos a tomar lectura de los datos del sensor y mostrar los resultados por el puerto serie. El c\u00f3digo del programa ( descargar ) es el siguiente: #include \"Adafruit_CCS811.h\" Adafruit_CCS811 ccs; void setup() { Serial.begin(9600); Serial.println(\"Prueba basica del sensor CCS811\"); if(!ccs.begin()){ Serial.println(\"\u00a1Error iniciando el sensor! Por favor revisar conexionado.\"); while(1); } //calibraci\u00f3n del sensor de temperatura while(!ccs.available()); float temperatura = ccs.calculateTemperature(); ccs.setTempOffset(temperatura - 20.0); //ajuste temperatura } void loop() { if(ccs.available()){ float temperatura = ccs.calculateTemperature(); if(!ccs.readData()){ //si no est\u00e1 tomando lectura enviar datos Serial.print(\"CO2: \"); Serial.print(ccs.geteCO2()); Serial.print(\" ppm, TVOC: \"); Serial.print(ccs.getTVOC()); Serial.print(\" ppb --- Temperatura: \"); Serial.print(temperatura); Serial.println(\" *C\"); } else{ Serial.println(\"\u00a1 ERROR !\"); while(1); } } delay(5000); } En la imagen siguiente podemos ver los resultados comentados. Resultados de la prueba inicial del sensor CCS811 En la web Sem\u00e1foro \u00f3ptico-ac\u00fastico de CO2 y nivel de ruido puedes aprender mucho mas acerca de este sensor y en general sobre conceptos de CO2 y VOC.","title":"Sensor CCS811 de eCO2, TVOC y temperatura"},{"location":"ccs811/#sensor-ccs811-de-eco2-tvoc-y-temperatura","text":"","title":"Sensor CCS811 de eCO2, TVOC y temperatura"},{"location":"ccs811/#descripcion","text":"El sensor mide par\u00e1metros de calidad del aire y utiliza el chip CCS811B. Es un peque\u00f1o sensor de gas digital de muy bajo consumo que puede detectar una amplia gama de compuestos org\u00e1nicos vol\u00e1tiles, incluidos los niveles equivalentes de di\u00f3xido de carbono (eCO2) y \u00f3xido met\u00e1lico (MOX). La respuesta del sensor al di\u00f3xido de carbono equivalente (eCO2) se mide en el rango de 400 a 8192 ppm, y otros compuestos org\u00e1nicos vol\u00e1tiles (TVOC, del ingl\u00e9s Volatile Organic Compound) var\u00edan de 0 a 1187 ppb. El sensor tambi\u00e9n cuenta con un termistor de precisi\u00f3n de 10K 1% tipo NTC, que se puede utilizar para medir la temperatura. Si queremos aprender mas sobre los VOC podemos hacerlo en el enlace Compuestos org\u00e1nicos vol\u00e1tiles pero al menos debemos saber que son liberados al quemar combustibles como gasolina, madera, carb\u00f3n o gas natural y que tambi\u00e9n son liberados por disolventes, pinturas y otros productos empleados y almacenados en la casa y el lugar de trabajo. Algunos ejemplos de compuestos org\u00e1nicos vol\u00e1tiles son: Naturales: isopreno, pineno y limoneno Artificiales: benceno, tolueno, nitrobenceno Otros ejemplos: formaldeh\u00eddo, clorobenceno, disolventes como tolueno, xileno, acetona y tetracloroetileno. En la wiki del enlace tenemos toda la informaci\u00f3n original del sensor KS0457 CCS811 de keyestudio que tiene el aspecto de la imagen siguiente: Aspecto del sensor CCS811","title":"Descripci\u00f3n"},{"location":"ccs811/#especificaciones","text":"Tensi\u00f3n de alimentaci\u00f3n: 5V DC Consumo: 30mA Potencia m\u00e1xima: 46mW Rango de medida eCO2: 400-8192 ppm Rango de medida TVOC: 0 to 1187 ppb Temperatura de trabajo: -25 ~ +65\u2103","title":"Especificaciones"},{"location":"ccs811/#distribucion-de-patillas","text":"En la imagen siguiente vemos el pinout del dispositivo. Pinout del sensor CCS811","title":"Distribuci\u00f3n de patillas"},{"location":"ccs811/#conexionado","text":"El conexionado b\u00e1sico del sensor lo vemos en la imagen siguiente que ha sido extraida de su wiki. Conexionado del sensor CCS811","title":"Conexionado"},{"location":"ccs811/#prueba-del-sensor-ccs811","text":"","title":"Prueba del sensor CCS811"},{"location":"ccs811/#libreria","text":"Para poder trabajar con este sensor necesitamos descargarnos e instalar la librer\u00eda Adafruit CCS811 que est\u00e1 disponible en el enlace. Si necesitas saber mas sobre librer\u00edas en Arduino u otras muchas cosas te recomiendo visitar la web de Luis del Valle Programarfacil y en concreto la entrada del blog C\u00f3mo instalar una librer\u00eda de Arduino en el entorno de desarrollo para aprender todo sobre las librer\u00edas. La propia librer\u00eda incluye dos ejemplos de uso y en base a ellos vamos a desarrollar el c\u00f3digo para la prueba del sensor.","title":"Librer\u00eda"},{"location":"ccs811/#prueba-inicial","text":"Vamos a tomar lectura de los datos del sensor y mostrar los resultados por el puerto serie. El c\u00f3digo del programa ( descargar ) es el siguiente: #include \"Adafruit_CCS811.h\" Adafruit_CCS811 ccs; void setup() { Serial.begin(9600); Serial.println(\"Prueba basica del sensor CCS811\"); if(!ccs.begin()){ Serial.println(\"\u00a1Error iniciando el sensor! Por favor revisar conexionado.\"); while(1); } //calibraci\u00f3n del sensor de temperatura while(!ccs.available()); float temperatura = ccs.calculateTemperature(); ccs.setTempOffset(temperatura - 20.0); //ajuste temperatura } void loop() { if(ccs.available()){ float temperatura = ccs.calculateTemperature(); if(!ccs.readData()){ //si no est\u00e1 tomando lectura enviar datos Serial.print(\"CO2: \"); Serial.print(ccs.geteCO2()); Serial.print(\" ppm, TVOC: \"); Serial.print(ccs.getTVOC()); Serial.print(\" ppb --- Temperatura: \"); Serial.print(temperatura); Serial.println(\" *C\"); } else{ Serial.println(\"\u00a1 ERROR !\"); while(1); } } delay(5000); } En la imagen siguiente podemos ver los resultados comentados. Resultados de la prueba inicial del sensor CCS811 En la web Sem\u00e1foro \u00f3ptico-ac\u00fastico de CO2 y nivel de ruido puedes aprender mucho mas acerca de este sensor y en general sobre conceptos de CO2 y VOC.","title":"Prueba inicial"},{"location":"crear-cuenta-AB/","text":"Crear una cuenta en ArduinoBlocks \u00b6 ArduinoBlocks es una plataforma online de JUAN JOS\u00c9 L\u00d3PEZ ALMENDROS. ArduinoBlocks es una plataforma web online donde podemos programar nuestra placa Arduino de forma visual. La programaci\u00f3n se realiza con bloques. La plataforma ArduinoBlocks genera, compila y sube el programa a la placa Arduino por medio de la conexi\u00f3n USB. ArduinoBlocks funciona con la mayor\u00eda de los navegadores: Mozilla Firefox, Google Chrome, Opera, Safari, etc. Accedemos a la web: http://www.arduinoblocks.com/ y cumplimentamos los datos solicitados. Datos para ArduinoBlocks Se crea la cuenta y nos muestra informaci\u00f3n de como proceder. Cuenta ArduinoBlocks Si volvemos a nuestra cuenta de Gmail vemos un nuevo mail. Verificaci\u00f3n de la cuenta ArduinoBlocks Abrimos el mail recibido y hacemos clic en el enlace. Verificaci\u00f3n de la cuenta ArduinoBlocks Hemos finalizado y recibiremos un mail de bienvenida. Cuenta ArduinoBlocks creada y mail de bienvenida Ya somos usuarios de ArduinoBlocks y podemos proceder a iniciar sesi\u00f3n. Inicio de sesi\u00f3n en ArduinoBlocks","title":"Crear cuenta en ArduinoBlocks"},{"location":"crear-cuenta-AB/#crear-una-cuenta-en-arduinoblocks","text":"ArduinoBlocks es una plataforma online de JUAN JOS\u00c9 L\u00d3PEZ ALMENDROS. ArduinoBlocks es una plataforma web online donde podemos programar nuestra placa Arduino de forma visual. La programaci\u00f3n se realiza con bloques. La plataforma ArduinoBlocks genera, compila y sube el programa a la placa Arduino por medio de la conexi\u00f3n USB. ArduinoBlocks funciona con la mayor\u00eda de los navegadores: Mozilla Firefox, Google Chrome, Opera, Safari, etc. Accedemos a la web: http://www.arduinoblocks.com/ y cumplimentamos los datos solicitados. Datos para ArduinoBlocks Se crea la cuenta y nos muestra informaci\u00f3n de como proceder. Cuenta ArduinoBlocks Si volvemos a nuestra cuenta de Gmail vemos un nuevo mail. Verificaci\u00f3n de la cuenta ArduinoBlocks Abrimos el mail recibido y hacemos clic en el enlace. Verificaci\u00f3n de la cuenta ArduinoBlocks Hemos finalizado y recibiremos un mail de bienvenida. Cuenta ArduinoBlocks creada y mail de bienvenida Ya somos usuarios de ArduinoBlocks y podemos proceder a iniciar sesi\u00f3n. Inicio de sesi\u00f3n en ArduinoBlocks","title":"Crear una cuenta en ArduinoBlocks"},{"location":"crear-cuenta-gmail/","text":"Crear una cuenta en Gmail \u00b6 Tenemos que usar una cuenta existente o seguir los pasos para crearnos una, por ejemplo en Gmail desde Mozilla Firefox. Si buscamos gmail debemos llegar a algo similar a lo que vemos en la imagen siguiente: Crear una cuenta en Gmail Cuando pulsamos en \"Crear una cuenta\" se nos muestra una pantalla en la que no pide los siguientes datos de la cuenta a crear: Nombre y apellidos Nombre de la cuenta. Importante recordarlo Contrase\u00f1a. Importante recordarlo Datos para crear una cuenta en Gmail Los datos opcionales son muy importantes si, por alg\u00fan motivo, necesitamos recuperar la cuenta en un futuro. Datos de verificaci\u00f3n de edad y sexo. Datos para verificar una cuenta en Gmail Verificaci\u00f3n del tel\u00e9fono suministrado. Verificaci\u00f3n mediante n\u00famero de tel\u00e9fono Tecleamos el c\u00f3digo recibido. Verificaci\u00f3n mediante n\u00famero de tel\u00e9fono En la pantalla siguiente seleccionamos seg\u00fan nuestras preferencias. Selecci\u00f3n seg\u00fan preferencias Leemos las condiciones que establece Google para poder crear una cuenta y marcamos para poder crear nuestra cuenta. Lectura y aceptaci\u00f3n condiciones Se muestra una pantalla de bienvenida como la siguiente: Pantalla de bienvenida a Gmail Escogemos el tipo de visualizaci\u00f3n seg\u00fan preferencias. Tipo de visualizaci\u00f3n Llegamos por fin a la pantalla inicial de nuestra cuenta de Gmail que ya est\u00e1 operativa. En la cuenta de Gmail Dejamos abierta la cuenta y seguimos el proceso para crear cuenta en ArduinoBlocks.","title":"Crear cuenta en Gmail"},{"location":"crear-cuenta-gmail/#crear-una-cuenta-en-gmail","text":"Tenemos que usar una cuenta existente o seguir los pasos para crearnos una, por ejemplo en Gmail desde Mozilla Firefox. Si buscamos gmail debemos llegar a algo similar a lo que vemos en la imagen siguiente: Crear una cuenta en Gmail Cuando pulsamos en \"Crear una cuenta\" se nos muestra una pantalla en la que no pide los siguientes datos de la cuenta a crear: Nombre y apellidos Nombre de la cuenta. Importante recordarlo Contrase\u00f1a. Importante recordarlo Datos para crear una cuenta en Gmail Los datos opcionales son muy importantes si, por alg\u00fan motivo, necesitamos recuperar la cuenta en un futuro. Datos de verificaci\u00f3n de edad y sexo. Datos para verificar una cuenta en Gmail Verificaci\u00f3n del tel\u00e9fono suministrado. Verificaci\u00f3n mediante n\u00famero de tel\u00e9fono Tecleamos el c\u00f3digo recibido. Verificaci\u00f3n mediante n\u00famero de tel\u00e9fono En la pantalla siguiente seleccionamos seg\u00fan nuestras preferencias. Selecci\u00f3n seg\u00fan preferencias Leemos las condiciones que establece Google para poder crear una cuenta y marcamos para poder crear nuestra cuenta. Lectura y aceptaci\u00f3n condiciones Se muestra una pantalla de bienvenida como la siguiente: Pantalla de bienvenida a Gmail Escogemos el tipo de visualizaci\u00f3n seg\u00fan preferencias. Tipo de visualizaci\u00f3n Llegamos por fin a la pantalla inicial de nuestra cuenta de Gmail que ya est\u00e1 operativa. En la cuenta de Gmail Dejamos abierta la cuenta y seguimos el proceso para crear cuenta en ArduinoBlocks.","title":"Crear una cuenta en Gmail"},{"location":"panel-I2C/","text":"Panel de sensores I2C, TdR STEAM y varias pantallas \u00b6 Este panel est\u00e1 constituido por una placa tipo UNO, la shield IMAGINA TdR STEAM y los sensores y actuadores que iremos mencionando. En la imagen siguiente vemos el aspecto de ambas placas. Placa tipo UNO de keyestudio Placa TdR STEAM Toda la informaci\u00f3n que necesitemos de la placa TdR STEAM la vamos a encontrar en la p\u00e1gina Retos con TdR-STEAM y Keyestudio UNO . Panel de sensores I2C \u00b6 KS0392. Keyestudio Hub I2C \u00b6 Para la expansi\u00f3n del conector I2C que integra la placa TdR STEAM utilizamos la shield de conversi\u00f3n I2C que vemos en la imagen siguiente. Hub I2C El conexionado entre la placa TdR STEAM y la shield tenemos que hacer con un un cable formado por cuatro conductores que en un extremo lleva un conector JST Macho de 4 pines (TdR) y en el otro un conector plano hembra tambi\u00e9n de 4 pines. El conector JST solamente puede colocarse en una posici\u00f3n y por lo tanto no hay posibilidad de error. Para colocar el conector plano nos fijamos en el nombre de uno de sus extremos en la shield y lo hacemos coincidir con el cable que corresponda en el conector JST, lo colocamos en su sitio y tenemos resuelta la conexi\u00f3n. Este mismo procedimiento lo llevaremos a cabo de forma similar con el resto de sensores y actuadores por lo que simplemente describimos los elementos usados en el panel. Ks0031. Sensor t\u00e1ctil capacitivo \u00b6 Este sensor puede \"sentir\" el tacto de las personas incluso aislado por alguna tela y papel. Su sensibilidad disminuye a medida que la capa de aislamiento se hace m\u00e1s gruesa. Su aspecto y el diagrama t\u00edpico de conexi\u00f3n lo vemos en la imagen siguiente. Sensor t\u00e1ctil capacitivo Diagrama de conexi\u00f3n t\u00edpico El bot\u00f3n t\u00e1ctil va conectado al conector D5 de la placa TdR STEAM a trav\u00e9s de un cable de 3 hilos apropiado. Indicar que este sensor no es I2C sino digital. KS0396. Matriz de LED 8x8 I2C direccionable \u00b6 En la programaci\u00f3n se va a establecer que el bot\u00f3n t\u00e1ctil sirva para cambiar de carita triste a carita sonriente la matriz de 8x8 LEDs al tiempo que emite un pitido el zumbador de la TdR STEAM. Esta matriz utiliza el chip HT16K33 para controlar los 8x8 puntos o LEDs. Dispone de tres interruptores DIP con los que podemos configurar la direcci\u00f3n de comunicaci\u00f3n I2C. Sus especificaciones t\u00e9cnicas son: Interfaz: 4Pin header Voltaje de funcionamiento: DC 4.5V-5.5V Direcci\u00f3n f\u00edsica: configurable Matriz de LED 8x8 I2C direccionable Diagrama de conexi\u00f3n t\u00edpico En la tabla siguiente vemos como configurar los interruptores DIP para obtener las diferentes direcciones f\u00edsicas disponibles. 3 2 1 Direcci\u00f3n Hexadecimal 0 0 0 0x70 0 0 1 0x71 0 1 0 0x72 0 1 1 0x73 1 0 0 0x74 1 0 1 0x75 1 1 0 0x76 1 1 1 0x77 Ks0061. Pantalla LCD 1602 I2C \u00b6 Pantalla LCD de 16 caracteres en 2 l\u00edneas con fondo azul y retroiluminaci\u00f3n de luz blanca. La LCD original 1602 necesita 7 puertos IO para estar en funcionamiento, en cambio esta, al ser I2C, permite ahorrar 5 puertos. Especificaciones: I2C Direcci\u00f3n: 0x27. Modificable por hardware. Retroiluminado (Azul con color blanco). Tensi\u00f3n de alimentaci\u00f3n: 5V. Interfaz: I2C. Contraste ajustable Pantalla LCD 1602 I2C Diagrama de conexi\u00f3n t\u00edpico En el panel vamos a disponer de dos pantallas, para visualizar diferentes datos. En la primera de ellas cuando accionamos el pulsador SW1 en la TdR STEAM veremos la temperatura y humedad tanto del sensor DHT22 externo como del DHT11 de la placa. Si accionamos el pulsador SW2 veremos los datos de luminosidad capturados por la LDR de la placa y los del sensor de luz ambiental. La otra LCD se va a dedicar a mostrar los datos capturados por el sensor de eCO2 CCS811. Para poder trabajar con dos pantallas de este tipo necesitamos cambiar la direcci\u00f3n f\u00edsica de una de ellas. En el enlace cambiar la direcci\u00f3n f\u00edsica... tenemos descrito este tema. Ks0098. Sensor de luz ambiente TEMT6000 \u00b6 Adaptado a la sensibilidad del ojo humano Sensor de luz ambiente Diagrama de conexi\u00f3n t\u00edpico Este sensor no es I2C sino anal\u00f3gico. KS0430. Sensor de temperatura y humedad \u00b6 Sensor que combina en una se\u00f1al digital la medida de temperatura y humedad. Sus especificaciones t\u00e9cnicas son: Voltaje de funcionamiento: DC 3.3V-5V Se\u00f1al de salida: digital de bus \u00fanico Rango de medici\u00f3n de humedad: 0 a 100% Precisi\u00f3n de medici\u00f3n de humedad: \u00b1 2% Rango de medici\u00f3n de temperatura: -40 \u00b0C a 80 \u00b0C Precisi\u00f3n de medici\u00f3n de temperatura: \u00b1 0.5 \u00b0C En la imagen siguiente vemos su aspecto y conexionado t\u00edpico. Sensor de temperatura y humedad Diagrama de conexi\u00f3n t\u00edpico Este sensor no es I2C sino digital. Ks0271. Pantalla OLED de 0.96\" \u00b6 Las siglas OLED (Organic Light Emitting Diode) pueden traducirse como Diodo Org\u00e1nico Emisor de Luz. A nivel microsc\u00f3pico, una pantalla OLED es una matriz de LED org\u00e1nicos que se encienden cuando emiten energ\u00eda. Voltaje de funcionamiento: DC 3.3V-5V N\u00famero de p\u00edxeles: 128 \u00d7 64 Profundidad de color: azul Forma de comunicaci\u00f3n: I2C En la imagen siguiente vemos su aspecto y conexionado t\u00edpico. Pantalla OLED de 0.96\" Diagrama de conexi\u00f3n t\u00edpico Utilizaremos la pantalla OLED para mostrar los \u00e1ngulos de rotaci\u00f3n ortogonales en los ejes X e Y. Ks0012. Aceler\u00f3metro de tres ejes ADXL345\" \u00b6 El ADXL345 es un aceler\u00f3metro capacitivo (MEMS) de 3 ejes de baja potencia con medici\u00f3n de alta resoluci\u00f3n (13 bits) de hasta \u00b116g. Los datos de salida digital est\u00e1n formateados con 16 bits y se puede acceder a trav\u00e9s de una interfaz digital SPI (3 o 4 hilos) o I2C. El ADXL345 es adecuado para medir la aceleraci\u00f3n est\u00e1tica de la gravedad en aplicaciones de detecci\u00f3n de inclinaci\u00f3n, as\u00ed como la aceleraci\u00f3n din\u00e1mica resultante del movimiento o el impacto. Su alta resoluci\u00f3n (4mg/LSB) permite la medici\u00f3n de cambios de inclinaci\u00f3n menores a 1.0 grado. Aceler\u00f3metro de tres ejes ADXL345 Diagrama de conexi\u00f3n t\u00edpico En estos sensores miden la rotaci\u00f3n del eje X (Roll), la rotaci\u00f3n del eje Y (Pitch) y la rotaci\u00f3n del eje Z (Yaw). Para saber mas sobre el tema se aconseja visitar la entrada medir la inclinaci\u00f3n con IMU disponible en el blog de Luis Llamas. KS0457. Sensor de eCO2 y TVOC CCS811 \u00b6 El sensor de gas CCS811B puede detectar una amplia gama de Compuestos Org\u00e1nicos Vol\u00e1tiles (VOCs) y est\u00e1 dise\u00f1ado para el monitoreo de la calidad del aire. Cuando se conecta a la placa de control devolver\u00e1 una lectura de Compuesto Org\u00e1nico Vol\u00e1til Total (TVOC) y una lectura de Di\u00f3xido de Carbono Equivalente (eCO2). Sus especificaciones t\u00e9cnicas son: Voltaje de trabajo: DC 5V Corriente de trabajo: 30mA Potencia m\u00e1xima: 46 mW Rango de medici\u00f3n de eCO2: 400-8192 ppm Rango de medici\u00f3n de TVOC: 0 a 1187 ppb Temperatura de trabajo: -25 a + 65 \u00b0C Para aprender mas sobre este sensor no dejes de visitar el enlace Sem\u00e1foro \u00f3ptico-ac\u00fastico de CO2 especialmente en su entrada Comparativa eCO2 versus CO2 Sensor de eCO2 y TVOC CCS811 Diagrama de conexi\u00f3n t\u00edpico KS0457. Sensor de color RGB TCS34725 \u00b6 El sensor puede reconocer el color de la superficie de un objeto a trav\u00e9s de la detecci\u00f3n \u00f3ptica. El sensor se ilumina con luz brillante y emite los valores RGB correspondientes. Adem\u00e1s, para evitar la interferencia del entorno y aumentar la precisi\u00f3n, dispone de una placa protectora de luz infrarroja en la parte inferior del sensor, de modo que el elemento de espectro infrarrojo de la luz incidente se minimiza para hacer que la gesti\u00f3n del color sea m\u00e1s precisa. En la parte inferior del sensor, se pueden ver 4 LEDs que garantizan que el sensor se pueda usar normalmente en condiciones de poca luz ambiental. Estas son sus especificaciones t\u00e9cnicas: Voltaje de funcionamiento: 3.3-5V Corriente de funcionamiento: 65uA Distancia medida: 3-10mm Frecuencia de reloj: 0-400KHZ Interfaz: I2C y paso de pin de 2,54 mm Rango de temperatura: -30 \u00b0C ~ + 70 En el panel se han dispuesto tres zonas de colores rojo, verde y azul que har\u00e1n que cuando acerquemos el sensor a alguna de ellas el LED RGB en la TdR STEAM se ilumine en ese color permanecienco apagado si no detecta ninguno de los tres colores. Sensor de color RGB TCS34725 Diagrama de conexi\u00f3n t\u00edpico Programaci\u00f3n del panel de sensores I2C \u00b6 El proyecto est\u00e1 como p\u00fablico en ArduinoBlocks en el siguiente enlace: acceder . Tambi\u00e9n lo tenemos disponible para descargar e importar en este enlace . El siguiente c\u00f3digo corresponde al programa elaborado en ArduinoBlocks. #include <SPI.h> #include <Wire.h> #include <Adafruit_GFX.h> #include <Adafruit_LEDBackpack.h> #include <Adafruit_SSD1306.h> #include \"ABlocks_LiquidCrystal_I2C.h\" #include <ABLocks_TimerFreeTone.h> #include \"ADXL345.h\" #include \"ABlocks_DHT.h\" #include \"ABlocks_DHT.h\" #include <Adafruit_CCS811.h> #include \"Adafruit_TCS34725.h\" #include \"ColorConverterLib.h\" double espera_con_bloqueo; double X; double Y; double TDHT11; double HDHT11; double TDHT22; double LDR; double CO2; double HDHT22; double VOC; double sen_luz_ambiente; boolean b_boton_tactil; boolean b_pulsador_2; boolean b_pulsador_1; Adafruit_8x8matrix ledmatrix_1 =Adafruit_8x8matrix(); Adafruit_SSD1306 oled_1(128,64, &Wire,-1); LiquidCrystal_I2C lcd_1(0x27,16,2); LiquidCrystal_I2C lcd_2(0x26,16,2); static const uint8_t PROGMEM ledmatrix_data_sprite_face_happy[] PROGMEM = {B00000000,B01100110,B01100110,B00000000,B00000000,B11000011,B01100110,B00111100}; static const uint8_t PROGMEM ledmatrix_data_sprite_face_sad[] PROGMEM = {B00000000,B01100110,B00100100,B00000000,B00111100,B01100110,B11000011,B10000001}; byte lcd_1_customchar_0[8]={B00100,B01010,B01010,B00100,B00000,B00000,B00000,B00000}; unsigned long task_time_ms=0; ADXL345 adxl345_accel; DHT dht4(4,DHT11); DHT dht3(3,DHT22); Adafruit_CCS811 sensor_ccs811; unsigned long sensor_ccs811_lastread=0; double sensor_ccs811_co2_ppm=0.0; double sensor_ccs811_co2_mgm3=0.0; double sensor_ccs811_co2_tvoc_ppb=0.0; Adafruit_TCS34725 tcs34725 = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_1X); double tcs34725_r=0; double tcs34725_g=0; double tcs34725_b=0; uint16_t tcs34725_clear=0; double tcs34725_h=0; double tcs34725_s=0; double tcs34725_v=0; void boton_tactil_matriz_8x8() { if (b_boton_tactil) { ledmatrix_1.setRotation(3); ledmatrix_1.clear(); ledmatrix_1.drawBitmap(0,0,ledmatrix_data_sprite_face_happy,8,8,LED_ON); ledmatrix_1.writeDisplay(); TimerFreeTone(8,523.26,200); delay(espera_con_bloqueo); TimerFreeTone(8,659.26,200); delay(espera_con_bloqueo); } else { ledmatrix_1.setRotation(3); ledmatrix_1.clear(); ledmatrix_1.drawBitmap(0,0,ledmatrix_data_sprite_face_sad,8,8,LED_ON); ledmatrix_1.writeDisplay(); } } void DHTs() { lcd_1.createChar(0, lcd_1_customchar_0); if (b_pulsador_1) { lcd_1.clear(); lcd_1.setCursor(0, 0); lcd_1.print(String(\"11:T=\")); lcd_1.setCursor(5, 0); lcd_1.print((unsigned long)(TDHT11)); lcd_1.setCursor(7, 0); lcd_1.write((byte)0); lcd_1.setCursor(8, 0); lcd_1.print(String(\"C\")); lcd_1.setCursor(9, 0); lcd_1.print(String(\"-\")); lcd_1.setCursor(10, 0); lcd_1.print(String(\"H=\")); lcd_1.setCursor(12, 0); lcd_1.print((unsigned long)(HDHT11)); lcd_1.setCursor(14, 0); lcd_1.print(String(\"%\")); lcd_1.setCursor(0, 1); lcd_1.print(String(\"22:T=\")); lcd_1.setCursor(5, 1); lcd_1.print((unsigned long)(TDHT22)); lcd_1.setCursor(7, 1); lcd_1.write((byte)0); lcd_1.setCursor(8, 1); lcd_1.print(String(\"C\")); lcd_1.setCursor(9, 1); lcd_1.print(String(\"-\")); lcd_1.setCursor(10, 1); lcd_1.print(String(\"H=\")); lcd_1.setCursor(12, 1); lcd_1.print((unsigned long)(HDHT22)); lcd_1.setCursor(14, 1); lcd_1.print(String(\"%\")); delay(1000); } else { lcd_1.clear(); } } void OLED_acelerometro() { if((millis()-task_time_ms)>=2000){ task_time_ms=millis(); oled_1.clearDisplay(); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(0,10); oled_1.print(String(\"X: \")); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(35,10); oled_1.print(X); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(0,40); oled_1.print(String(\"Y: \")); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(35,40); oled_1.print(Y); oled_1.display(); } } double fnc_adxl345(int _type) { double v=0.0; if(_type>=1 && _type<=3){ //raw data Vector data_raw = adxl345_accel.readRaw(); if(_type==1)v=data_raw.XAxis; if(_type==2)v=data_raw.YAxis; if(_type==3)v=data_raw.ZAxis; } else{ //noramlized data g=gravity Vector data_norm = adxl345_accel.readNormalize(); if(_type>=4 && _type<=6){ if(_type==4)v=data_norm.XAxis; if(_type==5)v=data_norm.YAxis; if(_type==6)v=data_norm.ZAxis; } else{ //pitch,roll degrees Vector data_filtered = adxl345_accel.lowPassFilter(data_norm, 0.5); if(_type==7)v=(atan2(data_filtered.YAxis, data_filtered.ZAxis)*180.0)/M_PI; if(_type==8)v=-(atan2(data_filtered.XAxis, sqrt(data_filtered.YAxis*data_filtered.YAxis + data_filtered.ZAxis*data_filtered.ZAxis))*180.0)/M_PI; } } return v; } double fnc_ccs811_data(int _type) { double v=0.0; if((millis()-sensor_ccs811_lastread)>=1000){ if(sensor_ccs811.available() && (!sensor_ccs811.readData()) ){ //update new values from sensor sensor_ccs811_co2_ppm=((double)sensor_ccs811.geteCO2()); sensor_ccs811_co2_mgm3=((double)sensor_ccs811_co2_ppm*(double)1.8); sensor_ccs811_co2_tvoc_ppb=((double)sensor_ccs811.getTVOC()); sensor_ccs811_lastread=millis(); } else{ //error reading sensor, reset values... sensor_ccs811_co2_ppm=0.0; sensor_ccs811_co2_mgm3=0.0; sensor_ccs811_co2_tvoc_ppb=0.0; } } //return value if(_type==0)v=sensor_ccs811_co2_ppm; if(_type==1)v=sensor_ccs811_co2_tvoc_ppb; if(_type==2)v=sensor_ccs811_co2_mgm3; return v; } void sensores() { b_boton_tactil = digitalRead(5); X = fnc_adxl345(7); Y = fnc_adxl345(8); TDHT11 = (unsigned long)(dht4.readTemperature()); HDHT11 = (unsigned long)(dht4.readHumidity()); TDHT22 = (unsigned long)(dht3.readTemperature()); HDHT22 = (unsigned long)(dht3.readHumidity()); b_pulsador_1 = digitalRead(2); b_pulsador_2 = digitalRead(7); sen_luz_ambiente = map(analogRead(A3),0,1023,0,100); LDR = map(analogRead(A1),0,1023,0,100); CO2 = fnc_ccs811_data(2); VOC = fnc_ccs811_data(1); } void fnc_tcs34725_capturecolor() { uint16_t tcs_red, tcs_green, tcs_blue; tcs34725.getRawData(&tcs_red, &tcs_green, &tcs_blue, &tcs34725_clear); if (tcs34725_clear == 0) { tcs34725_r=tcs34725_g=tcs34725_b=0; return; } tcs34725_r = ((float)tcs_red / (float)tcs34725_clear * 255.0); tcs34725_g = ((float)tcs_green / (float)tcs34725_clear * 255.0); tcs34725_b = ((float)tcs_blue / (float)tcs34725_clear * 255.0); ColorConverter::RgbToHsv(static_cast<uint8_t>(tcs34725_r), static_cast<uint8_t>(tcs34725_g), static_cast<uint8_t>(tcs34725_b), tcs34725_h, tcs34725_s,tcs34725_v); tcs34725_h=tcs34725_h*360; tcs34725_s=tcs34725_s*100; tcs34725_v=tcs34725_v*100; } bool fnc_tcs34725_iscolor(int _color) { if(tcs34725_h > 340 || tcs34725_h < 20){ if(_color==2) return true; } //red else if(tcs34725_h < 45){ if(_color==3) return true; } //orange else if(tcs34725_h < 70){ if(_color==4) return true; } //yellow else if(tcs34725_h < 150){ if(_color==5) return true; } //green else if(tcs34725_h < 210){ if(_color==6) return true; } //cyan else if(tcs34725_h < 265){ if(_color==7) return true; } //blue else if(tcs34725_h < 340){ if(_color==8) return true; } //violet return false; } void sensor_color_RGB() { fnc_tcs34725_capturecolor(); if (fnc_tcs34725_iscolor(2)) { analogWrite(6,255); analogWrite(9,0); analogWrite(10,0); } else if (fnc_tcs34725_iscolor(5)) { analogWrite(6,0); analogWrite(9,255); analogWrite(10,0); } else if (fnc_tcs34725_iscolor(7)) { analogWrite(6,0); analogWrite(9,0); analogWrite(10,255); } else { analogWrite(9,0); analogWrite(10,0); analogWrite(11,0); } } void luminosidad() { if (b_pulsador_2) { lcd_1.clear(); lcd_1.setCursor(0, 0); lcd_1.print(String(\"Luz LDR: \")); lcd_1.setCursor(9, 0); lcd_1.print((unsigned long)(LDR)); lcd_1.setCursor(13, 0); lcd_1.print(String(\"%\")); lcd_1.setCursor(0, 1); lcd_1.print(String(\"Luz TEMT: \")); lcd_1.setCursor(10, 1); lcd_1.print((unsigned long)(sen_luz_ambiente)); lcd_1.setCursor(13, 1); lcd_1.print(String(\"%\")); delay(1000); } else { lcd_1.clear(); } } void CO2_VOC() { lcd_2.clear(); lcd_2.setCursor(0, 0); lcd_2.print(String(\"CO2:\")); lcd_2.setCursor(0, 1); lcd_2.print(String(\"VOC:\")); lcd_2.setCursor(5, 0); lcd_2.print((unsigned long)(CO2)); lcd_2.setCursor(10, 0); lcd_2.print(String(\"mg/m3\")); lcd_2.setCursor(5, 1); lcd_2.print((unsigned long)(VOC)); lcd_2.setCursor(10, 1); lcd_2.print(String(\"ppb\")); delay(1000); } void variables() { espera_con_bloqueo = 100; X = 0; Y = 0; TDHT11 = 0; HDHT11 = 0; TDHT22 = 0; HDHT22 = 0; sen_luz_ambiente = 0; LDR = 0; CO2 = 0; VOC = 0; } void setup() { pinMode(8, OUTPUT); pinMode(5, INPUT); pinMode(4, INPUT); pinMode(3, INPUT); pinMode(2, INPUT); pinMode(7, INPUT); pinMode(A3, INPUT); pinMode(A1, INPUT); pinMode(6, OUTPUT); pinMode(9, OUTPUT); pinMode(10, OUTPUT); pinMode(11, OUTPUT); adxl345_accel.begin(); adxl345_accel.setRange(ADXL345_RANGE_16G); dht4.begin(); dht3.begin(); sensor_ccs811.begin(); tcs34725.begin(); ledmatrix_1.begin(0x70); ledmatrix_1.setType(0); ledmatrix_1.setTextWrap(false); ledmatrix_1.setTextSize(1); ledmatrix_1.clear(); ledmatrix_1.writeDisplay(); oled_1.begin(SSD1306_SWITCHCAPVCC,0x3C); oled_1.clearDisplay(); oled_1.display(); oled_1.setTextSize(2); oled_1.setTextColor(WHITE); oled_1.setCursor(35,15); oled_1.print(String(\"OLED\")); oled_1.display(); oled_1.setTextSize(2); oled_1.setTextColor(WHITE); oled_1.setCursor(10,35); oled_1.print(String(\"iniciada\")); oled_1.display(); lcd_1.begin(); lcd_1.noCursor(); lcd_1.backlight(); lcd_1.clear(); lcd_1.setCursor(1, 0); lcd_1.print(String(\"LCD 1 iniciada\")); lcd_2.begin(); lcd_2.noCursor(); lcd_2.backlight(); lcd_2.clear(); lcd_2.setCursor(1, 0); lcd_2.print(String(\"LCD 2 iniciada\")); variables(); } void loop() { sensores(); boton_tactil_matriz_8x8(); OLED_acelerometro(); sensor_color_RGB(); DHTs(); luminosidad(); CO2_VOC(); }","title":"Panel de sensores I2C"},{"location":"panel-I2C/#panel-de-sensores-i2c-tdr-steam-y-varias-pantallas","text":"Este panel est\u00e1 constituido por una placa tipo UNO, la shield IMAGINA TdR STEAM y los sensores y actuadores que iremos mencionando. En la imagen siguiente vemos el aspecto de ambas placas. Placa tipo UNO de keyestudio Placa TdR STEAM Toda la informaci\u00f3n que necesitemos de la placa TdR STEAM la vamos a encontrar en la p\u00e1gina Retos con TdR-STEAM y Keyestudio UNO .","title":"Panel de sensores I2C, TdR STEAM y varias pantallas"},{"location":"panel-I2C/#panel-de-sensores-i2c","text":"","title":"Panel de sensores I2C"},{"location":"panel-I2C/#ks0392-keyestudio-hub-i2c","text":"Para la expansi\u00f3n del conector I2C que integra la placa TdR STEAM utilizamos la shield de conversi\u00f3n I2C que vemos en la imagen siguiente. Hub I2C El conexionado entre la placa TdR STEAM y la shield tenemos que hacer con un un cable formado por cuatro conductores que en un extremo lleva un conector JST Macho de 4 pines (TdR) y en el otro un conector plano hembra tambi\u00e9n de 4 pines. El conector JST solamente puede colocarse en una posici\u00f3n y por lo tanto no hay posibilidad de error. Para colocar el conector plano nos fijamos en el nombre de uno de sus extremos en la shield y lo hacemos coincidir con el cable que corresponda en el conector JST, lo colocamos en su sitio y tenemos resuelta la conexi\u00f3n. Este mismo procedimiento lo llevaremos a cabo de forma similar con el resto de sensores y actuadores por lo que simplemente describimos los elementos usados en el panel.","title":"KS0392. Keyestudio Hub I2C"},{"location":"panel-I2C/#ks0031-sensor-tactil-capacitivo","text":"Este sensor puede \"sentir\" el tacto de las personas incluso aislado por alguna tela y papel. Su sensibilidad disminuye a medida que la capa de aislamiento se hace m\u00e1s gruesa. Su aspecto y el diagrama t\u00edpico de conexi\u00f3n lo vemos en la imagen siguiente. Sensor t\u00e1ctil capacitivo Diagrama de conexi\u00f3n t\u00edpico El bot\u00f3n t\u00e1ctil va conectado al conector D5 de la placa TdR STEAM a trav\u00e9s de un cable de 3 hilos apropiado. Indicar que este sensor no es I2C sino digital.","title":"Ks0031. Sensor t\u00e1ctil capacitivo"},{"location":"panel-I2C/#ks0396-matriz-de-led-8x8-i2c-direccionable","text":"En la programaci\u00f3n se va a establecer que el bot\u00f3n t\u00e1ctil sirva para cambiar de carita triste a carita sonriente la matriz de 8x8 LEDs al tiempo que emite un pitido el zumbador de la TdR STEAM. Esta matriz utiliza el chip HT16K33 para controlar los 8x8 puntos o LEDs. Dispone de tres interruptores DIP con los que podemos configurar la direcci\u00f3n de comunicaci\u00f3n I2C. Sus especificaciones t\u00e9cnicas son: Interfaz: 4Pin header Voltaje de funcionamiento: DC 4.5V-5.5V Direcci\u00f3n f\u00edsica: configurable Matriz de LED 8x8 I2C direccionable Diagrama de conexi\u00f3n t\u00edpico En la tabla siguiente vemos como configurar los interruptores DIP para obtener las diferentes direcciones f\u00edsicas disponibles. 3 2 1 Direcci\u00f3n Hexadecimal 0 0 0 0x70 0 0 1 0x71 0 1 0 0x72 0 1 1 0x73 1 0 0 0x74 1 0 1 0x75 1 1 0 0x76 1 1 1 0x77","title":"KS0396. Matriz de LED 8x8 I2C direccionable"},{"location":"panel-I2C/#ks0061-pantalla-lcd-1602-i2c","text":"Pantalla LCD de 16 caracteres en 2 l\u00edneas con fondo azul y retroiluminaci\u00f3n de luz blanca. La LCD original 1602 necesita 7 puertos IO para estar en funcionamiento, en cambio esta, al ser I2C, permite ahorrar 5 puertos. Especificaciones: I2C Direcci\u00f3n: 0x27. Modificable por hardware. Retroiluminado (Azul con color blanco). Tensi\u00f3n de alimentaci\u00f3n: 5V. Interfaz: I2C. Contraste ajustable Pantalla LCD 1602 I2C Diagrama de conexi\u00f3n t\u00edpico En el panel vamos a disponer de dos pantallas, para visualizar diferentes datos. En la primera de ellas cuando accionamos el pulsador SW1 en la TdR STEAM veremos la temperatura y humedad tanto del sensor DHT22 externo como del DHT11 de la placa. Si accionamos el pulsador SW2 veremos los datos de luminosidad capturados por la LDR de la placa y los del sensor de luz ambiental. La otra LCD se va a dedicar a mostrar los datos capturados por el sensor de eCO2 CCS811. Para poder trabajar con dos pantallas de este tipo necesitamos cambiar la direcci\u00f3n f\u00edsica de una de ellas. En el enlace cambiar la direcci\u00f3n f\u00edsica... tenemos descrito este tema.","title":"Ks0061. Pantalla LCD 1602 I2C"},{"location":"panel-I2C/#ks0098-sensor-de-luz-ambiente-temt6000","text":"Adaptado a la sensibilidad del ojo humano Sensor de luz ambiente Diagrama de conexi\u00f3n t\u00edpico Este sensor no es I2C sino anal\u00f3gico.","title":"Ks0098. Sensor de luz ambiente TEMT6000"},{"location":"panel-I2C/#ks0430-sensor-de-temperatura-y-humedad","text":"Sensor que combina en una se\u00f1al digital la medida de temperatura y humedad. Sus especificaciones t\u00e9cnicas son: Voltaje de funcionamiento: DC 3.3V-5V Se\u00f1al de salida: digital de bus \u00fanico Rango de medici\u00f3n de humedad: 0 a 100% Precisi\u00f3n de medici\u00f3n de humedad: \u00b1 2% Rango de medici\u00f3n de temperatura: -40 \u00b0C a 80 \u00b0C Precisi\u00f3n de medici\u00f3n de temperatura: \u00b1 0.5 \u00b0C En la imagen siguiente vemos su aspecto y conexionado t\u00edpico. Sensor de temperatura y humedad Diagrama de conexi\u00f3n t\u00edpico Este sensor no es I2C sino digital.","title":"KS0430. Sensor de temperatura y humedad"},{"location":"panel-I2C/#ks0271-pantalla-oled-de-096","text":"Las siglas OLED (Organic Light Emitting Diode) pueden traducirse como Diodo Org\u00e1nico Emisor de Luz. A nivel microsc\u00f3pico, una pantalla OLED es una matriz de LED org\u00e1nicos que se encienden cuando emiten energ\u00eda. Voltaje de funcionamiento: DC 3.3V-5V N\u00famero de p\u00edxeles: 128 \u00d7 64 Profundidad de color: azul Forma de comunicaci\u00f3n: I2C En la imagen siguiente vemos su aspecto y conexionado t\u00edpico. Pantalla OLED de 0.96\" Diagrama de conexi\u00f3n t\u00edpico Utilizaremos la pantalla OLED para mostrar los \u00e1ngulos de rotaci\u00f3n ortogonales en los ejes X e Y.","title":"Ks0271. Pantalla OLED de 0.96\""},{"location":"panel-I2C/#ks0012-acelerometro-de-tres-ejes-adxl345","text":"El ADXL345 es un aceler\u00f3metro capacitivo (MEMS) de 3 ejes de baja potencia con medici\u00f3n de alta resoluci\u00f3n (13 bits) de hasta \u00b116g. Los datos de salida digital est\u00e1n formateados con 16 bits y se puede acceder a trav\u00e9s de una interfaz digital SPI (3 o 4 hilos) o I2C. El ADXL345 es adecuado para medir la aceleraci\u00f3n est\u00e1tica de la gravedad en aplicaciones de detecci\u00f3n de inclinaci\u00f3n, as\u00ed como la aceleraci\u00f3n din\u00e1mica resultante del movimiento o el impacto. Su alta resoluci\u00f3n (4mg/LSB) permite la medici\u00f3n de cambios de inclinaci\u00f3n menores a 1.0 grado. Aceler\u00f3metro de tres ejes ADXL345 Diagrama de conexi\u00f3n t\u00edpico En estos sensores miden la rotaci\u00f3n del eje X (Roll), la rotaci\u00f3n del eje Y (Pitch) y la rotaci\u00f3n del eje Z (Yaw). Para saber mas sobre el tema se aconseja visitar la entrada medir la inclinaci\u00f3n con IMU disponible en el blog de Luis Llamas.","title":"Ks0012. Aceler\u00f3metro de tres ejes ADXL345\""},{"location":"panel-I2C/#ks0457-sensor-de-eco2-y-tvoc-ccs811","text":"El sensor de gas CCS811B puede detectar una amplia gama de Compuestos Org\u00e1nicos Vol\u00e1tiles (VOCs) y est\u00e1 dise\u00f1ado para el monitoreo de la calidad del aire. Cuando se conecta a la placa de control devolver\u00e1 una lectura de Compuesto Org\u00e1nico Vol\u00e1til Total (TVOC) y una lectura de Di\u00f3xido de Carbono Equivalente (eCO2). Sus especificaciones t\u00e9cnicas son: Voltaje de trabajo: DC 5V Corriente de trabajo: 30mA Potencia m\u00e1xima: 46 mW Rango de medici\u00f3n de eCO2: 400-8192 ppm Rango de medici\u00f3n de TVOC: 0 a 1187 ppb Temperatura de trabajo: -25 a + 65 \u00b0C Para aprender mas sobre este sensor no dejes de visitar el enlace Sem\u00e1foro \u00f3ptico-ac\u00fastico de CO2 especialmente en su entrada Comparativa eCO2 versus CO2 Sensor de eCO2 y TVOC CCS811 Diagrama de conexi\u00f3n t\u00edpico","title":"KS0457. Sensor de eCO2 y TVOC CCS811"},{"location":"panel-I2C/#ks0457-sensor-de-color-rgb-tcs34725","text":"El sensor puede reconocer el color de la superficie de un objeto a trav\u00e9s de la detecci\u00f3n \u00f3ptica. El sensor se ilumina con luz brillante y emite los valores RGB correspondientes. Adem\u00e1s, para evitar la interferencia del entorno y aumentar la precisi\u00f3n, dispone de una placa protectora de luz infrarroja en la parte inferior del sensor, de modo que el elemento de espectro infrarrojo de la luz incidente se minimiza para hacer que la gesti\u00f3n del color sea m\u00e1s precisa. En la parte inferior del sensor, se pueden ver 4 LEDs que garantizan que el sensor se pueda usar normalmente en condiciones de poca luz ambiental. Estas son sus especificaciones t\u00e9cnicas: Voltaje de funcionamiento: 3.3-5V Corriente de funcionamiento: 65uA Distancia medida: 3-10mm Frecuencia de reloj: 0-400KHZ Interfaz: I2C y paso de pin de 2,54 mm Rango de temperatura: -30 \u00b0C ~ + 70 En el panel se han dispuesto tres zonas de colores rojo, verde y azul que har\u00e1n que cuando acerquemos el sensor a alguna de ellas el LED RGB en la TdR STEAM se ilumine en ese color permanecienco apagado si no detecta ninguno de los tres colores. Sensor de color RGB TCS34725 Diagrama de conexi\u00f3n t\u00edpico","title":"KS0457. Sensor de color RGB TCS34725"},{"location":"panel-I2C/#programacion-del-panel-de-sensores-i2c","text":"El proyecto est\u00e1 como p\u00fablico en ArduinoBlocks en el siguiente enlace: acceder . Tambi\u00e9n lo tenemos disponible para descargar e importar en este enlace . El siguiente c\u00f3digo corresponde al programa elaborado en ArduinoBlocks. #include <SPI.h> #include <Wire.h> #include <Adafruit_GFX.h> #include <Adafruit_LEDBackpack.h> #include <Adafruit_SSD1306.h> #include \"ABlocks_LiquidCrystal_I2C.h\" #include <ABLocks_TimerFreeTone.h> #include \"ADXL345.h\" #include \"ABlocks_DHT.h\" #include \"ABlocks_DHT.h\" #include <Adafruit_CCS811.h> #include \"Adafruit_TCS34725.h\" #include \"ColorConverterLib.h\" double espera_con_bloqueo; double X; double Y; double TDHT11; double HDHT11; double TDHT22; double LDR; double CO2; double HDHT22; double VOC; double sen_luz_ambiente; boolean b_boton_tactil; boolean b_pulsador_2; boolean b_pulsador_1; Adafruit_8x8matrix ledmatrix_1 =Adafruit_8x8matrix(); Adafruit_SSD1306 oled_1(128,64, &Wire,-1); LiquidCrystal_I2C lcd_1(0x27,16,2); LiquidCrystal_I2C lcd_2(0x26,16,2); static const uint8_t PROGMEM ledmatrix_data_sprite_face_happy[] PROGMEM = {B00000000,B01100110,B01100110,B00000000,B00000000,B11000011,B01100110,B00111100}; static const uint8_t PROGMEM ledmatrix_data_sprite_face_sad[] PROGMEM = {B00000000,B01100110,B00100100,B00000000,B00111100,B01100110,B11000011,B10000001}; byte lcd_1_customchar_0[8]={B00100,B01010,B01010,B00100,B00000,B00000,B00000,B00000}; unsigned long task_time_ms=0; ADXL345 adxl345_accel; DHT dht4(4,DHT11); DHT dht3(3,DHT22); Adafruit_CCS811 sensor_ccs811; unsigned long sensor_ccs811_lastread=0; double sensor_ccs811_co2_ppm=0.0; double sensor_ccs811_co2_mgm3=0.0; double sensor_ccs811_co2_tvoc_ppb=0.0; Adafruit_TCS34725 tcs34725 = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_1X); double tcs34725_r=0; double tcs34725_g=0; double tcs34725_b=0; uint16_t tcs34725_clear=0; double tcs34725_h=0; double tcs34725_s=0; double tcs34725_v=0; void boton_tactil_matriz_8x8() { if (b_boton_tactil) { ledmatrix_1.setRotation(3); ledmatrix_1.clear(); ledmatrix_1.drawBitmap(0,0,ledmatrix_data_sprite_face_happy,8,8,LED_ON); ledmatrix_1.writeDisplay(); TimerFreeTone(8,523.26,200); delay(espera_con_bloqueo); TimerFreeTone(8,659.26,200); delay(espera_con_bloqueo); } else { ledmatrix_1.setRotation(3); ledmatrix_1.clear(); ledmatrix_1.drawBitmap(0,0,ledmatrix_data_sprite_face_sad,8,8,LED_ON); ledmatrix_1.writeDisplay(); } } void DHTs() { lcd_1.createChar(0, lcd_1_customchar_0); if (b_pulsador_1) { lcd_1.clear(); lcd_1.setCursor(0, 0); lcd_1.print(String(\"11:T=\")); lcd_1.setCursor(5, 0); lcd_1.print((unsigned long)(TDHT11)); lcd_1.setCursor(7, 0); lcd_1.write((byte)0); lcd_1.setCursor(8, 0); lcd_1.print(String(\"C\")); lcd_1.setCursor(9, 0); lcd_1.print(String(\"-\")); lcd_1.setCursor(10, 0); lcd_1.print(String(\"H=\")); lcd_1.setCursor(12, 0); lcd_1.print((unsigned long)(HDHT11)); lcd_1.setCursor(14, 0); lcd_1.print(String(\"%\")); lcd_1.setCursor(0, 1); lcd_1.print(String(\"22:T=\")); lcd_1.setCursor(5, 1); lcd_1.print((unsigned long)(TDHT22)); lcd_1.setCursor(7, 1); lcd_1.write((byte)0); lcd_1.setCursor(8, 1); lcd_1.print(String(\"C\")); lcd_1.setCursor(9, 1); lcd_1.print(String(\"-\")); lcd_1.setCursor(10, 1); lcd_1.print(String(\"H=\")); lcd_1.setCursor(12, 1); lcd_1.print((unsigned long)(HDHT22)); lcd_1.setCursor(14, 1); lcd_1.print(String(\"%\")); delay(1000); } else { lcd_1.clear(); } } void OLED_acelerometro() { if((millis()-task_time_ms)>=2000){ task_time_ms=millis(); oled_1.clearDisplay(); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(0,10); oled_1.print(String(\"X: \")); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(35,10); oled_1.print(X); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(0,40); oled_1.print(String(\"Y: \")); oled_1.display(); oled_1.setTextSize(3); oled_1.setTextColor(WHITE); oled_1.setCursor(35,40); oled_1.print(Y); oled_1.display(); } } double fnc_adxl345(int _type) { double v=0.0; if(_type>=1 && _type<=3){ //raw data Vector data_raw = adxl345_accel.readRaw(); if(_type==1)v=data_raw.XAxis; if(_type==2)v=data_raw.YAxis; if(_type==3)v=data_raw.ZAxis; } else{ //noramlized data g=gravity Vector data_norm = adxl345_accel.readNormalize(); if(_type>=4 && _type<=6){ if(_type==4)v=data_norm.XAxis; if(_type==5)v=data_norm.YAxis; if(_type==6)v=data_norm.ZAxis; } else{ //pitch,roll degrees Vector data_filtered = adxl345_accel.lowPassFilter(data_norm, 0.5); if(_type==7)v=(atan2(data_filtered.YAxis, data_filtered.ZAxis)*180.0)/M_PI; if(_type==8)v=-(atan2(data_filtered.XAxis, sqrt(data_filtered.YAxis*data_filtered.YAxis + data_filtered.ZAxis*data_filtered.ZAxis))*180.0)/M_PI; } } return v; } double fnc_ccs811_data(int _type) { double v=0.0; if((millis()-sensor_ccs811_lastread)>=1000){ if(sensor_ccs811.available() && (!sensor_ccs811.readData()) ){ //update new values from sensor sensor_ccs811_co2_ppm=((double)sensor_ccs811.geteCO2()); sensor_ccs811_co2_mgm3=((double)sensor_ccs811_co2_ppm*(double)1.8); sensor_ccs811_co2_tvoc_ppb=((double)sensor_ccs811.getTVOC()); sensor_ccs811_lastread=millis(); } else{ //error reading sensor, reset values... sensor_ccs811_co2_ppm=0.0; sensor_ccs811_co2_mgm3=0.0; sensor_ccs811_co2_tvoc_ppb=0.0; } } //return value if(_type==0)v=sensor_ccs811_co2_ppm; if(_type==1)v=sensor_ccs811_co2_tvoc_ppb; if(_type==2)v=sensor_ccs811_co2_mgm3; return v; } void sensores() { b_boton_tactil = digitalRead(5); X = fnc_adxl345(7); Y = fnc_adxl345(8); TDHT11 = (unsigned long)(dht4.readTemperature()); HDHT11 = (unsigned long)(dht4.readHumidity()); TDHT22 = (unsigned long)(dht3.readTemperature()); HDHT22 = (unsigned long)(dht3.readHumidity()); b_pulsador_1 = digitalRead(2); b_pulsador_2 = digitalRead(7); sen_luz_ambiente = map(analogRead(A3),0,1023,0,100); LDR = map(analogRead(A1),0,1023,0,100); CO2 = fnc_ccs811_data(2); VOC = fnc_ccs811_data(1); } void fnc_tcs34725_capturecolor() { uint16_t tcs_red, tcs_green, tcs_blue; tcs34725.getRawData(&tcs_red, &tcs_green, &tcs_blue, &tcs34725_clear); if (tcs34725_clear == 0) { tcs34725_r=tcs34725_g=tcs34725_b=0; return; } tcs34725_r = ((float)tcs_red / (float)tcs34725_clear * 255.0); tcs34725_g = ((float)tcs_green / (float)tcs34725_clear * 255.0); tcs34725_b = ((float)tcs_blue / (float)tcs34725_clear * 255.0); ColorConverter::RgbToHsv(static_cast<uint8_t>(tcs34725_r), static_cast<uint8_t>(tcs34725_g), static_cast<uint8_t>(tcs34725_b), tcs34725_h, tcs34725_s,tcs34725_v); tcs34725_h=tcs34725_h*360; tcs34725_s=tcs34725_s*100; tcs34725_v=tcs34725_v*100; } bool fnc_tcs34725_iscolor(int _color) { if(tcs34725_h > 340 || tcs34725_h < 20){ if(_color==2) return true; } //red else if(tcs34725_h < 45){ if(_color==3) return true; } //orange else if(tcs34725_h < 70){ if(_color==4) return true; } //yellow else if(tcs34725_h < 150){ if(_color==5) return true; } //green else if(tcs34725_h < 210){ if(_color==6) return true; } //cyan else if(tcs34725_h < 265){ if(_color==7) return true; } //blue else if(tcs34725_h < 340){ if(_color==8) return true; } //violet return false; } void sensor_color_RGB() { fnc_tcs34725_capturecolor(); if (fnc_tcs34725_iscolor(2)) { analogWrite(6,255); analogWrite(9,0); analogWrite(10,0); } else if (fnc_tcs34725_iscolor(5)) { analogWrite(6,0); analogWrite(9,255); analogWrite(10,0); } else if (fnc_tcs34725_iscolor(7)) { analogWrite(6,0); analogWrite(9,0); analogWrite(10,255); } else { analogWrite(9,0); analogWrite(10,0); analogWrite(11,0); } } void luminosidad() { if (b_pulsador_2) { lcd_1.clear(); lcd_1.setCursor(0, 0); lcd_1.print(String(\"Luz LDR: \")); lcd_1.setCursor(9, 0); lcd_1.print((unsigned long)(LDR)); lcd_1.setCursor(13, 0); lcd_1.print(String(\"%\")); lcd_1.setCursor(0, 1); lcd_1.print(String(\"Luz TEMT: \")); lcd_1.setCursor(10, 1); lcd_1.print((unsigned long)(sen_luz_ambiente)); lcd_1.setCursor(13, 1); lcd_1.print(String(\"%\")); delay(1000); } else { lcd_1.clear(); } } void CO2_VOC() { lcd_2.clear(); lcd_2.setCursor(0, 0); lcd_2.print(String(\"CO2:\")); lcd_2.setCursor(0, 1); lcd_2.print(String(\"VOC:\")); lcd_2.setCursor(5, 0); lcd_2.print((unsigned long)(CO2)); lcd_2.setCursor(10, 0); lcd_2.print(String(\"mg/m3\")); lcd_2.setCursor(5, 1); lcd_2.print((unsigned long)(VOC)); lcd_2.setCursor(10, 1); lcd_2.print(String(\"ppb\")); delay(1000); } void variables() { espera_con_bloqueo = 100; X = 0; Y = 0; TDHT11 = 0; HDHT11 = 0; TDHT22 = 0; HDHT22 = 0; sen_luz_ambiente = 0; LDR = 0; CO2 = 0; VOC = 0; } void setup() { pinMode(8, OUTPUT); pinMode(5, INPUT); pinMode(4, INPUT); pinMode(3, INPUT); pinMode(2, INPUT); pinMode(7, INPUT); pinMode(A3, INPUT); pinMode(A1, INPUT); pinMode(6, OUTPUT); pinMode(9, OUTPUT); pinMode(10, OUTPUT); pinMode(11, OUTPUT); adxl345_accel.begin(); adxl345_accel.setRange(ADXL345_RANGE_16G); dht4.begin(); dht3.begin(); sensor_ccs811.begin(); tcs34725.begin(); ledmatrix_1.begin(0x70); ledmatrix_1.setType(0); ledmatrix_1.setTextWrap(false); ledmatrix_1.setTextSize(1); ledmatrix_1.clear(); ledmatrix_1.writeDisplay(); oled_1.begin(SSD1306_SWITCHCAPVCC,0x3C); oled_1.clearDisplay(); oled_1.display(); oled_1.setTextSize(2); oled_1.setTextColor(WHITE); oled_1.setCursor(35,15); oled_1.print(String(\"OLED\")); oled_1.display(); oled_1.setTextSize(2); oled_1.setTextColor(WHITE); oled_1.setCursor(10,35); oled_1.print(String(\"iniciada\")); oled_1.display(); lcd_1.begin(); lcd_1.noCursor(); lcd_1.backlight(); lcd_1.clear(); lcd_1.setCursor(1, 0); lcd_1.print(String(\"LCD 1 iniciada\")); lcd_2.begin(); lcd_2.noCursor(); lcd_2.backlight(); lcd_2.clear(); lcd_2.setCursor(1, 0); lcd_2.print(String(\"LCD 2 iniciada\")); variables(); } void loop() { sensores(); boton_tactil_matriz_8x8(); OLED_acelerometro(); sensor_color_RGB(); DHTs(); luminosidad(); CO2_VOC(); }","title":"Programaci\u00f3n del panel de sensores I2C"},{"location":"panel-easy-plug/","text":"Panel de sensores Easy Plug \u00b6 Panel de sensores y conexionado \u00b6 Ks0240. Placa UNO Easy plug \u00b6 Disponemos de una placa de control Ks0240 como la de la imagen siguiente. Placa UNO Easy plug Las caracter\u00edsticas de la placa Keyestudio Easy plug V2.0 son: 5 puertos digitales simples (D5 a D9) 3 puertos PWM (D5, D6 y D9) 1 puerto digital doble (D3-D4) 4 entradas anal\u00f3gicas (A0 a A3) 1 interface mixto digital/anal\u00f3gico (D2-A6-A7) 1 puerto de comunicaci\u00f3n SPI 1 puerto de comunicaci\u00f3n serie COM 1 interface de comunicaci\u00f3n I2C 1 conector USB B 1 jack de alimentaci\u00f3n (7 a 12V) 2 conectores ICSP Todos los conectores RJ11 6P6C tienen Vcc y GND Para la conexi\u00f3n entre placa de control y ordenador necesitamos un cable USB B a USB A como el de la imagen siguiente. Cable USB B-A KS0390. Placa de conversi\u00f3n e interface I2C \u00b6 Los conectores macho configuran 5 puertos de comunicaci\u00f3n, lo que permite realizar comunicaci\u00f3n I2C con 4 sensores con esta conexi\u00f3n al mismo tiempo. Los conectores Easy plug configuran 6 puertos de comunicaci\u00f3n, lo que permite realizar comunicaci\u00f3n I2C con 5 sensores con esta conexi\u00f3n al mismo tiempo. Se utiliza para ampliar el n\u00famero de sensores I2C que se conectan a este puerto configurando diferentes direcciones. El aspecto del HUB I2C es el de la imagen siguiente: HUB I2C Easy Plug Conectamos mediante uno de los cables Easy Plug el HUB I2C a la placa de control, tal y como vemos en la imagen siguiente: Conexi\u00f3n HUB I2C Easy Plug KS0381. Pantalla LCD EASY plug I2C 1602 \u00b6 La pantalla LCD es de 2 lineas y 16 caracteres por l\u00ednea, configurada con la direcci\u00f3n I2C 0x27 y la utilizaremos para visualizar mensajes en ella. En la imagen siguiente vemos el aspecto de la pantalla y su conexionado. LCD 1602 Conexi\u00f3n LCD Ks0112. Bot\u00f3n pulsador EASY plug \u00b6 Cuando se pulsa el bot\u00f3n, se emite una se\u00f1al de nivel ALTO; si se suelta, emite una se\u00f1al de nivel BAJO. Se utiliza para cambiar el nivel de estado de una entrada digital de BAJO a ALTO. Dispondremos dos botones para movernos hac\u00eda adelante o hac\u00eda atr\u00e1s en la visualizaci\u00f3n de los datos suministrados por los sensores. El aspecto del bot\u00f3n y la conexi\u00f3n de los dos necesarios lo vemos en la imagen siguiente. Bot\u00f3n pulsador Conexi\u00f3n botones Ks0224/Ks0225/Ks0226. Diodos LED EASY plug \u00b6 Para mostrar el estado de una determinada salida. * Ks0224 - LED rojo * Ks0225 - LED verde * Ks0226 - LED amarillo Se utiliza en nuestro proyecto para visualizar el estado de los pulsadores seg\u00fan el siguiente criterio: * LED verde: Avance * LED rojo: Atr\u00e1s * LED amarillo: ning\u00fan pulsador accionado En la imagen siguiente tenemos el aspecto de los tres diodos y de su conexionado. Diodos LED Conexi\u00f3n de los tres diodos LED KS0431. Sensor de Temperatura y Humedad EASY plug \u00b6 Sensor compuesto que contiene una se\u00f1al de salida digital calibrada de temperatura y humedad relativa. El rango de medidas es: * Humedad Relativa (HR): 0 a 100% * Precisi\u00f3n HR: \u00b12% * Temperatura (T): de - 40\u2103 a 80\u2103 * Precisi\u00f3n T: \u00b10.5\u2103 Se utiliza para visualizar estos dos par\u00e1metros. En la imagen vemos su aspecto y conexionado. Sensor DHT22 Conexi\u00f3n del DHT22 Ks0133. Sensor EASY plug de calidad del aire \u00b6 El sensor MQ135 utiliza como material sensible SnO2 por su baja conductividad el\u00e9ctrica en aire limpio. Cuando est\u00e1 rodeado de aire contaminado, la conductividad el\u00e9ctrica del sensor MQ135 aumentar\u00e1, y este cambio se convierte en se\u00f1al el\u00e9ctrica de salida correspondiente. El potenci\u00f3metro permite ajustar la sensibilidad. Es sensible al amon\u00edaco, sulfuro, vapor de benceno, humo y otros gases nocivos. Se utiliza para medir de forma anal\u00f3gica el valor entregado. Su aspecto y conexionado lo vemos en la imagen siguiente. Sensor MQ135 Conexi\u00f3n del MQ135 Ks0106. LDR EASY plug \u00b6 Una fotorresistencia o resistencia dependiente de la luz (LDR) es una resistencia variable controlada por la luz. El principio es muy simple, la resistencia del fotorresistor var\u00eda con la intensidad de la luz incidente. Si la intensidad de la luz incidente es alta, la resistencia disminuye; Si la intensidad de la luz es baja, la resistencia aumenta. Se utiliza para comprobar las variaciones de luz en el entorno de la LDR someti\u00e9ndola a luz ambiente, tap\u00e1ndola y acerc\u00e1ndola a una fuente de luz. En la imagen siguiente vemos su aspecto y el conexionado en este proyecto. LDR Conexi\u00f3n LDR Ks0134. Sensor EASY plug de Presi\u00f3n Barom\u00e9trica \u00b6 Sensor para medida de presi\u00f3n atmosf\u00e9rica y c\u00e1lculo de altitud sobre el nivel del mar. Incorpora sensor de temperatura porque la necesita para las otras medidas. Rango de presi\u00f3n: 300 a 1100 hPa (Hecto Pascales) Rango de altitud: de 500 a 9000 metros. Interface I2C Se utiliza para visualizar la altitud sobre el nivel del mar y la presi\u00f3n barom\u00e9trica correspondiente a la posici\u00f3n actual del sensor. En la imagen siguiente vemos su aspecto y el conexionado. BMP180 Conexi\u00f3n BMP180 KS2002. Sensor EASY plug CCS811 de eCO2 y TVOC \u00b6 El sensor CCS811B Easy Plug puede detectar una amplia gama de Compuestos Org\u00e1nicos Vol\u00e1tiles (VOCs) y est\u00e1 dise\u00f1ado para el monitoreo de la calidad del aire. Cuando se conecta a la placa devolver\u00e1 una lectura de TVOC y una lectura de Di\u00f3xido de Carbono Equivalente (eCO2). Sus principales especificaciones son: Voltaje de funcionamiento: DC 5 V Corriente de trabajo: 30 mA Potencia m\u00e1xima: 60 mW Rango de medici\u00f3n de eCO2: 400-29206 ppm Rango de medici\u00f3n TVOC: 0 a 32768 ppb Interfaz de comunicaci\u00f3n: I2C En la imagen siguiente vemos su aspecto y el conexionado. CCS811B Conexi\u00f3n CCS811B Conexionado panel Easy Plug \u00b6 En la imagen siguiente tenemos todas las conexiones del proyecto. Conexiones panel de sensores Easy plug Programaci\u00f3n del panel de sensores Easy Plug \u00b6 El proyecto est\u00e1 como p\u00fablico en ArduinoBlocks en el siguiente enlace: acceder Tambi\u00e9n lo tenemos disponible para descargar e importar a ArduinoBlocks en este enlace . El siguiente c\u00f3digo corresponde al programa elaborado en ArduinoBlocks. #include <Wire.h> #include \"ABlocks_LiquidCrystal_I2C.h\" #include \"ABlocks_Button.h\" #include \"ABlocks_DHT.h\" #include <Adafruit_BMP085.h> #include <Adafruit_CCS811.h> double Temperatura; double Humedad; double CalidadAire; double luminosidad; double opcion; double Presion; double Altitud; double T_BMP; double eCO2; double TVOC; boolean b_avance; boolean b_atras; LiquidCrystal_I2C lcd_1(0x27,16,2); byte lcd_1_customchar_0[8]={B00010,B00101,B00010,B00000,B00000,B00000,B00000,B00000}; LiquidCrystal_I2C lcd(0x27,16,2); Button button_debounced_5(5,50); Button button_debounced_6(6,50); DHT dht9(9,DHT22); Adafruit_BMP085 bmp180; Adafruit_CCS811 sensor_ccs811; unsigned long sensor_ccs811_lastread=0; double sensor_ccs811_co2_ppm=0.0; double sensor_ccs811_co2_mgm3=0.0; double sensor_ccs811_co2_tvoc_ppb=0.0; void configurar() { lcd.backlight(); lcd.clear(); digitalWrite(A3, HIGH); digitalWrite(5, HIGH); digitalWrite(6, HIGH); } void bienvenida() { lcd.clear(); lcd.setCursor(1, 0); lcd.print(String(\"Club Robotica\")); lcd.setCursor(4, 1); lcd.print(String(\"Granada\")); delay(3000); lcd.setCursor(1, 0); lcd.print(String(\"Panel Sensores\")); lcd.setCursor(4, 1); lcd.print(String(\"Easy Plug\")); delay(3000); lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\" Pulsadores\")); lcd.setCursor(0, 1); lcd.print(String(\"Avance Atras\")); } void encenderLED() { digitalWrite(7, HIGH); digitalWrite(8, HIGH); digitalWrite(A3, HIGH); } void apagarR() { digitalWrite(7, LOW); } void encenderR() { digitalWrite(7, HIGH); } void encenderG() { digitalWrite(8, HIGH); } void apagarG() { digitalWrite(8, LOW); } void apagarLED() { digitalWrite(7, LOW); digitalWrite(8, LOW); digitalWrite(A3, LOW); } void encenderY() { digitalWrite(A3, HIGH); } void apagarY() { digitalWrite(A3, LOW); } void leerPulsador() { b_avance = button_debounced_5.pressed(); b_atras = button_debounced_6.pressed(); encenderY(); if (b_avance) { apagarY(); encenderG(); if ((opcion < 7)) { opcion = (opcion + 1); } } if (b_atras) { apagarY(); encenderR(); if ((opcion > 1)) { opcion = (opcion - 1); } } delay(500); apagarG(); apagarR(); } double fnc_ccs811_data(int _type) { double v=0.0; if((millis()-sensor_ccs811_lastread)>=1000){ if(sensor_ccs811.available() && (!sensor_ccs811.readData()) ){ //update new values from sensor sensor_ccs811_co2_ppm=((double)sensor_ccs811.geteCO2()); sensor_ccs811_co2_mgm3=((double)sensor_ccs811_co2_ppm*(double)1.8); sensor_ccs811_co2_tvoc_ppb=((double)sensor_ccs811.getTVOC()); sensor_ccs811_lastread=millis(); } else{ //error reading sensor, reset values... sensor_ccs811_co2_ppm=0.0; sensor_ccs811_co2_mgm3=0.0; sensor_ccs811_co2_tvoc_ppb=0.0; } } //return value if(_type==0)v=sensor_ccs811_co2_ppm; if(_type==1)v=sensor_ccs811_co2_tvoc_ppb; if(_type==2)v=sensor_ccs811_co2_mgm3; return v; } void leerSensores() { Temperatura = dht9.readTemperature(); Humedad = dht9.readHumidity(); CalidadAire = analogRead(A7); luminosidad = map(analogRead(A0),0,1023,0,100); Presion = (bmp180.readPressure()/100.0); Altitud = bmp180.readAltitude(); T_BMP = bmp180.readTemperature(); eCO2 = fnc_ccs811_data(2); TVOC = fnc_ccs811_data(1); } void setup() { pinMode(A3, OUTPUT); pinMode(5, OUTPUT); pinMode(6, OUTPUT); pinMode(7, OUTPUT); pinMode(8, OUTPUT); pinMode(5, INPUT); pinMode(6, INPUT); pinMode(9, INPUT); pinMode(A7, INPUT); pinMode(A0, INPUT); lcd.begin();lcd.noCursor();lcd.backlight(); dht9.begin(); bmp180.begin(); sensor_ccs811.begin(); lcd_1.begin(); lcd_1.noCursor(); lcd_1.backlight(); lcd_1.createChar(0, lcd_1_customchar_0); encenderLED(); configurar(); bienvenida(); apagarLED(); opcion = 0; } void loop() { leerPulsador(); leerSensores(); while ((opcion == 1)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Temperatura: \")); lcd.setCursor(4, 1); lcd.print(Temperatura); lcd_1.setCursor(10, 1); lcd_1.write((byte)0); lcd.setCursor(11, 1); lcd.print(String(\"C\")); leerPulsador(); leerSensores(); delay(10); } while ((opcion == 2)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Humedad: \")); lcd.setCursor(6, 1); lcd.print((long)(Humedad)); lcd.setCursor(9, 1); lcd.print(String(\"%\")); leerPulsador(); leerSensores(); } while ((opcion == 3)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Calidad Aire:\")); lcd.setCursor(6, 1); lcd.print((long)(CalidadAire)); leerPulsador(); leerSensores(); } while ((opcion == 4)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Luminosidad:\")); lcd.setCursor(5, 1); lcd.print((long)(luminosidad)); lcd.setCursor(8, 1); lcd.print(String(\"%\")); leerPulsador(); leerSensores(); } while ((opcion == 5)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Presion: \")); lcd.setCursor(4, 1); lcd.print((long)(Presion)); lcd.setCursor(9, 1); lcd.print(String(\"HPa\")); leerPulsador(); leerSensores(); } while ((opcion == 6)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Altitud: \")); lcd.setCursor(4, 1); lcd.print((long)(Altitud)); lcd.setCursor(10, 1); lcd.print(String(\"m\")); leerPulsador(); leerSensores(); } while ((opcion == 7)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"eCO2: \")); lcd.setCursor(6, 0); lcd.print((unsigned long)(eCO2)); lcd.setCursor(10, 0); lcd.print(String(\"mg/m3\")); lcd.setCursor(0, 1); lcd.print(String(\"TVOC: \")); lcd.setCursor(6, 1); lcd.print((unsigned long)(TVOC)); lcd.setCursor(10, 1); lcd.print(String(\"ppb\")); leerPulsador(); leerSensores(); } }","title":"Panel de sensores Easy Plug"},{"location":"panel-easy-plug/#panel-de-sensores-easy-plug","text":"","title":"Panel de sensores Easy Plug"},{"location":"panel-easy-plug/#panel-de-sensores-y-conexionado","text":"","title":"Panel de sensores y conexionado"},{"location":"panel-easy-plug/#ks0240-placa-uno-easy-plug","text":"Disponemos de una placa de control Ks0240 como la de la imagen siguiente. Placa UNO Easy plug Las caracter\u00edsticas de la placa Keyestudio Easy plug V2.0 son: 5 puertos digitales simples (D5 a D9) 3 puertos PWM (D5, D6 y D9) 1 puerto digital doble (D3-D4) 4 entradas anal\u00f3gicas (A0 a A3) 1 interface mixto digital/anal\u00f3gico (D2-A6-A7) 1 puerto de comunicaci\u00f3n SPI 1 puerto de comunicaci\u00f3n serie COM 1 interface de comunicaci\u00f3n I2C 1 conector USB B 1 jack de alimentaci\u00f3n (7 a 12V) 2 conectores ICSP Todos los conectores RJ11 6P6C tienen Vcc y GND Para la conexi\u00f3n entre placa de control y ordenador necesitamos un cable USB B a USB A como el de la imagen siguiente. Cable USB B-A","title":"Ks0240. Placa UNO Easy plug"},{"location":"panel-easy-plug/#ks0390-placa-de-conversion-e-interface-i2c","text":"Los conectores macho configuran 5 puertos de comunicaci\u00f3n, lo que permite realizar comunicaci\u00f3n I2C con 4 sensores con esta conexi\u00f3n al mismo tiempo. Los conectores Easy plug configuran 6 puertos de comunicaci\u00f3n, lo que permite realizar comunicaci\u00f3n I2C con 5 sensores con esta conexi\u00f3n al mismo tiempo. Se utiliza para ampliar el n\u00famero de sensores I2C que se conectan a este puerto configurando diferentes direcciones. El aspecto del HUB I2C es el de la imagen siguiente: HUB I2C Easy Plug Conectamos mediante uno de los cables Easy Plug el HUB I2C a la placa de control, tal y como vemos en la imagen siguiente: Conexi\u00f3n HUB I2C Easy Plug","title":"KS0390. Placa de conversi\u00f3n e interface I2C"},{"location":"panel-easy-plug/#ks0381-pantalla-lcd-easy-plug-i2c-1602","text":"La pantalla LCD es de 2 lineas y 16 caracteres por l\u00ednea, configurada con la direcci\u00f3n I2C 0x27 y la utilizaremos para visualizar mensajes en ella. En la imagen siguiente vemos el aspecto de la pantalla y su conexionado. LCD 1602 Conexi\u00f3n LCD","title":"KS0381. Pantalla LCD EASY plug I2C 1602"},{"location":"panel-easy-plug/#ks0112-boton-pulsador-easy-plug","text":"Cuando se pulsa el bot\u00f3n, se emite una se\u00f1al de nivel ALTO; si se suelta, emite una se\u00f1al de nivel BAJO. Se utiliza para cambiar el nivel de estado de una entrada digital de BAJO a ALTO. Dispondremos dos botones para movernos hac\u00eda adelante o hac\u00eda atr\u00e1s en la visualizaci\u00f3n de los datos suministrados por los sensores. El aspecto del bot\u00f3n y la conexi\u00f3n de los dos necesarios lo vemos en la imagen siguiente. Bot\u00f3n pulsador Conexi\u00f3n botones","title":"Ks0112. Bot\u00f3n pulsador EASY plug"},{"location":"panel-easy-plug/#ks0224ks0225ks0226-diodos-led-easy-plug","text":"Para mostrar el estado de una determinada salida. * Ks0224 - LED rojo * Ks0225 - LED verde * Ks0226 - LED amarillo Se utiliza en nuestro proyecto para visualizar el estado de los pulsadores seg\u00fan el siguiente criterio: * LED verde: Avance * LED rojo: Atr\u00e1s * LED amarillo: ning\u00fan pulsador accionado En la imagen siguiente tenemos el aspecto de los tres diodos y de su conexionado. Diodos LED Conexi\u00f3n de los tres diodos LED","title":"Ks0224/Ks0225/Ks0226. Diodos LED EASY plug"},{"location":"panel-easy-plug/#ks0431-sensor-de-temperatura-y-humedad-easy-plug","text":"Sensor compuesto que contiene una se\u00f1al de salida digital calibrada de temperatura y humedad relativa. El rango de medidas es: * Humedad Relativa (HR): 0 a 100% * Precisi\u00f3n HR: \u00b12% * Temperatura (T): de - 40\u2103 a 80\u2103 * Precisi\u00f3n T: \u00b10.5\u2103 Se utiliza para visualizar estos dos par\u00e1metros. En la imagen vemos su aspecto y conexionado. Sensor DHT22 Conexi\u00f3n del DHT22","title":"KS0431. Sensor de Temperatura y Humedad EASY plug"},{"location":"panel-easy-plug/#ks0133-sensor-easy-plug-de-calidad-del-aire","text":"El sensor MQ135 utiliza como material sensible SnO2 por su baja conductividad el\u00e9ctrica en aire limpio. Cuando est\u00e1 rodeado de aire contaminado, la conductividad el\u00e9ctrica del sensor MQ135 aumentar\u00e1, y este cambio se convierte en se\u00f1al el\u00e9ctrica de salida correspondiente. El potenci\u00f3metro permite ajustar la sensibilidad. Es sensible al amon\u00edaco, sulfuro, vapor de benceno, humo y otros gases nocivos. Se utiliza para medir de forma anal\u00f3gica el valor entregado. Su aspecto y conexionado lo vemos en la imagen siguiente. Sensor MQ135 Conexi\u00f3n del MQ135","title":"Ks0133. Sensor EASY plug de calidad del aire"},{"location":"panel-easy-plug/#ks0106-ldr-easy-plug","text":"Una fotorresistencia o resistencia dependiente de la luz (LDR) es una resistencia variable controlada por la luz. El principio es muy simple, la resistencia del fotorresistor var\u00eda con la intensidad de la luz incidente. Si la intensidad de la luz incidente es alta, la resistencia disminuye; Si la intensidad de la luz es baja, la resistencia aumenta. Se utiliza para comprobar las variaciones de luz en el entorno de la LDR someti\u00e9ndola a luz ambiente, tap\u00e1ndola y acerc\u00e1ndola a una fuente de luz. En la imagen siguiente vemos su aspecto y el conexionado en este proyecto. LDR Conexi\u00f3n LDR","title":"Ks0106. LDR EASY plug"},{"location":"panel-easy-plug/#ks0134-sensor-easy-plug-de-presion-barometrica","text":"Sensor para medida de presi\u00f3n atmosf\u00e9rica y c\u00e1lculo de altitud sobre el nivel del mar. Incorpora sensor de temperatura porque la necesita para las otras medidas. Rango de presi\u00f3n: 300 a 1100 hPa (Hecto Pascales) Rango de altitud: de 500 a 9000 metros. Interface I2C Se utiliza para visualizar la altitud sobre el nivel del mar y la presi\u00f3n barom\u00e9trica correspondiente a la posici\u00f3n actual del sensor. En la imagen siguiente vemos su aspecto y el conexionado. BMP180 Conexi\u00f3n BMP180","title":"Ks0134. Sensor EASY plug de Presi\u00f3n Barom\u00e9trica"},{"location":"panel-easy-plug/#ks2002-sensor-easy-plug-ccs811-de-eco2-y-tvoc","text":"El sensor CCS811B Easy Plug puede detectar una amplia gama de Compuestos Org\u00e1nicos Vol\u00e1tiles (VOCs) y est\u00e1 dise\u00f1ado para el monitoreo de la calidad del aire. Cuando se conecta a la placa devolver\u00e1 una lectura de TVOC y una lectura de Di\u00f3xido de Carbono Equivalente (eCO2). Sus principales especificaciones son: Voltaje de funcionamiento: DC 5 V Corriente de trabajo: 30 mA Potencia m\u00e1xima: 60 mW Rango de medici\u00f3n de eCO2: 400-29206 ppm Rango de medici\u00f3n TVOC: 0 a 32768 ppb Interfaz de comunicaci\u00f3n: I2C En la imagen siguiente vemos su aspecto y el conexionado. CCS811B Conexi\u00f3n CCS811B","title":"KS2002. Sensor EASY plug CCS811 de eCO2 y TVOC"},{"location":"panel-easy-plug/#conexionado-panel-easy-plug","text":"En la imagen siguiente tenemos todas las conexiones del proyecto. Conexiones panel de sensores Easy plug","title":"Conexionado panel Easy Plug"},{"location":"panel-easy-plug/#programacion-del-panel-de-sensores-easy-plug","text":"El proyecto est\u00e1 como p\u00fablico en ArduinoBlocks en el siguiente enlace: acceder Tambi\u00e9n lo tenemos disponible para descargar e importar a ArduinoBlocks en este enlace . El siguiente c\u00f3digo corresponde al programa elaborado en ArduinoBlocks. #include <Wire.h> #include \"ABlocks_LiquidCrystal_I2C.h\" #include \"ABlocks_Button.h\" #include \"ABlocks_DHT.h\" #include <Adafruit_BMP085.h> #include <Adafruit_CCS811.h> double Temperatura; double Humedad; double CalidadAire; double luminosidad; double opcion; double Presion; double Altitud; double T_BMP; double eCO2; double TVOC; boolean b_avance; boolean b_atras; LiquidCrystal_I2C lcd_1(0x27,16,2); byte lcd_1_customchar_0[8]={B00010,B00101,B00010,B00000,B00000,B00000,B00000,B00000}; LiquidCrystal_I2C lcd(0x27,16,2); Button button_debounced_5(5,50); Button button_debounced_6(6,50); DHT dht9(9,DHT22); Adafruit_BMP085 bmp180; Adafruit_CCS811 sensor_ccs811; unsigned long sensor_ccs811_lastread=0; double sensor_ccs811_co2_ppm=0.0; double sensor_ccs811_co2_mgm3=0.0; double sensor_ccs811_co2_tvoc_ppb=0.0; void configurar() { lcd.backlight(); lcd.clear(); digitalWrite(A3, HIGH); digitalWrite(5, HIGH); digitalWrite(6, HIGH); } void bienvenida() { lcd.clear(); lcd.setCursor(1, 0); lcd.print(String(\"Club Robotica\")); lcd.setCursor(4, 1); lcd.print(String(\"Granada\")); delay(3000); lcd.setCursor(1, 0); lcd.print(String(\"Panel Sensores\")); lcd.setCursor(4, 1); lcd.print(String(\"Easy Plug\")); delay(3000); lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\" Pulsadores\")); lcd.setCursor(0, 1); lcd.print(String(\"Avance Atras\")); } void encenderLED() { digitalWrite(7, HIGH); digitalWrite(8, HIGH); digitalWrite(A3, HIGH); } void apagarR() { digitalWrite(7, LOW); } void encenderR() { digitalWrite(7, HIGH); } void encenderG() { digitalWrite(8, HIGH); } void apagarG() { digitalWrite(8, LOW); } void apagarLED() { digitalWrite(7, LOW); digitalWrite(8, LOW); digitalWrite(A3, LOW); } void encenderY() { digitalWrite(A3, HIGH); } void apagarY() { digitalWrite(A3, LOW); } void leerPulsador() { b_avance = button_debounced_5.pressed(); b_atras = button_debounced_6.pressed(); encenderY(); if (b_avance) { apagarY(); encenderG(); if ((opcion < 7)) { opcion = (opcion + 1); } } if (b_atras) { apagarY(); encenderR(); if ((opcion > 1)) { opcion = (opcion - 1); } } delay(500); apagarG(); apagarR(); } double fnc_ccs811_data(int _type) { double v=0.0; if((millis()-sensor_ccs811_lastread)>=1000){ if(sensor_ccs811.available() && (!sensor_ccs811.readData()) ){ //update new values from sensor sensor_ccs811_co2_ppm=((double)sensor_ccs811.geteCO2()); sensor_ccs811_co2_mgm3=((double)sensor_ccs811_co2_ppm*(double)1.8); sensor_ccs811_co2_tvoc_ppb=((double)sensor_ccs811.getTVOC()); sensor_ccs811_lastread=millis(); } else{ //error reading sensor, reset values... sensor_ccs811_co2_ppm=0.0; sensor_ccs811_co2_mgm3=0.0; sensor_ccs811_co2_tvoc_ppb=0.0; } } //return value if(_type==0)v=sensor_ccs811_co2_ppm; if(_type==1)v=sensor_ccs811_co2_tvoc_ppb; if(_type==2)v=sensor_ccs811_co2_mgm3; return v; } void leerSensores() { Temperatura = dht9.readTemperature(); Humedad = dht9.readHumidity(); CalidadAire = analogRead(A7); luminosidad = map(analogRead(A0),0,1023,0,100); Presion = (bmp180.readPressure()/100.0); Altitud = bmp180.readAltitude(); T_BMP = bmp180.readTemperature(); eCO2 = fnc_ccs811_data(2); TVOC = fnc_ccs811_data(1); } void setup() { pinMode(A3, OUTPUT); pinMode(5, OUTPUT); pinMode(6, OUTPUT); pinMode(7, OUTPUT); pinMode(8, OUTPUT); pinMode(5, INPUT); pinMode(6, INPUT); pinMode(9, INPUT); pinMode(A7, INPUT); pinMode(A0, INPUT); lcd.begin();lcd.noCursor();lcd.backlight(); dht9.begin(); bmp180.begin(); sensor_ccs811.begin(); lcd_1.begin(); lcd_1.noCursor(); lcd_1.backlight(); lcd_1.createChar(0, lcd_1_customchar_0); encenderLED(); configurar(); bienvenida(); apagarLED(); opcion = 0; } void loop() { leerPulsador(); leerSensores(); while ((opcion == 1)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Temperatura: \")); lcd.setCursor(4, 1); lcd.print(Temperatura); lcd_1.setCursor(10, 1); lcd_1.write((byte)0); lcd.setCursor(11, 1); lcd.print(String(\"C\")); leerPulsador(); leerSensores(); delay(10); } while ((opcion == 2)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Humedad: \")); lcd.setCursor(6, 1); lcd.print((long)(Humedad)); lcd.setCursor(9, 1); lcd.print(String(\"%\")); leerPulsador(); leerSensores(); } while ((opcion == 3)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Calidad Aire:\")); lcd.setCursor(6, 1); lcd.print((long)(CalidadAire)); leerPulsador(); leerSensores(); } while ((opcion == 4)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Luminosidad:\")); lcd.setCursor(5, 1); lcd.print((long)(luminosidad)); lcd.setCursor(8, 1); lcd.print(String(\"%\")); leerPulsador(); leerSensores(); } while ((opcion == 5)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Presion: \")); lcd.setCursor(4, 1); lcd.print((long)(Presion)); lcd.setCursor(9, 1); lcd.print(String(\"HPa\")); leerPulsador(); leerSensores(); } while ((opcion == 6)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"Altitud: \")); lcd.setCursor(4, 1); lcd.print((long)(Altitud)); lcd.setCursor(10, 1); lcd.print(String(\"m\")); leerPulsador(); leerSensores(); } while ((opcion == 7)) { lcd.clear(); lcd.setCursor(0, 0); lcd.print(String(\"eCO2: \")); lcd.setCursor(6, 0); lcd.print((unsigned long)(eCO2)); lcd.setCursor(10, 0); lcd.print(String(\"mg/m3\")); lcd.setCursor(0, 1); lcd.print(String(\"TVOC: \")); lcd.setCursor(6, 1); lcd.print((unsigned long)(TVOC)); lcd.setCursor(10, 1); lcd.print(String(\"ppb\")); leerPulsador(); leerSensores(); } }","title":"Programaci\u00f3n del panel de sensores Easy Plug"},{"location":"plataformaAB/","text":"La plataforma ArduinoBlocks \u00b6 Descripci\u00f3n del entorno \u00b6 Para a\u00f1adir bloques al programa arrastramos desde la barra de herramientas al \u00e1rea de programa, insertando dentro del bloque de inicializaci\u00f3n o de bucle. Pantalla inicial de ArduinoBlocks Si no son funciones, todos los bloques fuera de los dos por defecto son ignorados. ArduinoBlocks genera el c\u00f3digo de Arduino a partir de los bloques. El programa se puede compilar y subir directamente a la placa Arduino gracias a la aplicaci\u00f3n ArduinoBlocks-Connector Descripciones de la pantalla inicial de ArduinoBlocks ArduinoBlocks genera el c\u00f3digo de Arduino a partir de los bloques. Si deseamos ver o descargar el c\u00f3digo podemos realizarlo desde el \u00e1rea de bloques. Ver el c\u00f3digo generado por ArduinoBlocks Si hacemos clic en el bot\u00f3n \"Informaci\u00f3n\" accedemos a toda la informaci\u00f3n del proyecto para cumplimentar o editar y tambi\u00e9n nos permite hacer nuestro proyecto p\u00fablico. Informaci\u00f3n del proyecto Si hacemos clic en el bot\u00f3n archivos accedemos a las opciones que se describen en la imagen siguiente: Archivos del proyecto Es muy interesante subir esquemas de montaje del proyecto realizados por ejemplo con Fritzing. Si hacemos clic en el desplegable de la llave fija se muestra un men\u00fa que nos permite crear s\u00edmbolos de una forma sencilla para diferentes dispositivos de visualizaci\u00f3n y tambi\u00e9n un enlace a informaci\u00f3n sobre RTTTL. Bot\u00f3n herramientas En la imagen siguiente se realiza la descripci\u00f3n del resto de botones e informaci\u00f3n disponible en esta barra. Resto de la barra de botones La imagen a la izquierda del nombre del proyecto es un enlace a una p\u00e1gina de ArduinoBlocks con informaci\u00f3n de la placa usada. Aunque ArduinoBlocks guarda de forma autom\u00e1tica cada cierto tiempo, podemos hacerlo de forma manual pulsando sobre el disquete o sobre el desplegable. La principal utilidad es la de crear un nuevo proyecto a partir del actual pulsando la opci\u00f3n \u201cGuardar como\u201d, lo que abrir\u00e1 el nuevo proyecto creado a partir del primero. Tambi\u00e9n permite generar el proyecto para alumnos, cambiar de tipo de proyecto, o sea cambiar la placa usada dentro de las opciones disponibles y exportar el archivo a nuestro ordenador. La ventana para cambiar el tipo de proyecto se muestra en la imagen siguiente: Opciones para cambiar el tipo de proyecto Si accedemos a Buscar proyectos podremos visualizar los compartidos por otros usuarios, completar las opciones de b\u00fasqueda que nos interesen, ver informaci\u00f3n del proyecto c\u00f3mo los \u201cMe gusta o Like\u201d, ver el n\u00famero de visualizaciones que tiene y visualizarlo nosotros mismos. Opciones de \"Buscaar proyectos\" Al acceder a visualizar un proyecto compartido por otro usuario nos aparecer\u00e1 un bot\u00f3n \u201cimportar a mis proyectos\u201d, que nos permite crear una copia del proyecto en mis proyectos personales para poder modificarlo a nuestro gusto. Tenemos un bot\u00f3n \u201cMe gusta\u201d que nos permite valorar positivamente el trabajo realizado por el usuario. Visualizar un proyecto compartido Estructura de un proyecto \u00b6 Un proyecto Arduino tiene siempre dos estructuras importantes en su interior. Vamos a crear un ejemplo sencillo al que llamaremos Blink escogiendo tipo Arduino UNO. Estructura b\u00e1sica de un proyecto Blink \u00b6 Vamos a hacer que al iniciar (o hacer reset) se env\u00ede el mensaje por el puerto serie \u201cInicializaci\u00f3n del proyecto Blink\u201d. Para ello procedemos como se ve en la imagen siguiente. Configuraci\u00f3n de Inicializar para el proyecto Blink ArduinoBlocks connector \u00b6 Es una aplicaci\u00f3n puente entre la plataforma on-line ArduinoBlocks y el hardware Arduino. La aplicaci\u00f3n recibe el c\u00f3digo generado por ArduinoBlocks, lo compila y lo sube a la placa Arduino. Est\u00e1 disponible para los principales sistemas operativos. En el \u00e1rea de descargas de Arduinoblocks.com se puede obtener la \u00faltima versi\u00f3n y m\u00e1s informaci\u00f3n sobre el proceso de instalaci\u00f3n y configuraci\u00f3n. Connector . Aspecto de la p\u00e1gina de descarga de Connector Para poder grabar nuestro proyecto en la placa Arduino necesitamos tener activado Connector. En la imagen siguiente vemos el icono y el programa en ejecuci\u00f3n. ArduinoBlocks Connector Ya podemos grabar el firmware directamente en nuestra placa a trav\u00e9s de Connector. Para ello conectamos la placa a un puerto USB y hacemos clic en Subir y al cabo de unos instantes veremos algo similar a lo de la imagen siguiente: Blink subido correctamente Ya hemos probado la comunicaci\u00f3n entre la plataforma y nuestro equipo y podemos continuar con el proyecto Blink. Continuaci\u00f3n de Blink \u00b6 Consultando el pinout de la placa Arduino UNO vemos que en el pin 13 est\u00e1 conectado el LED L, como vemos en la imagen siguiente. Vamos a hacerlo parpadear. LED onboard conectado a D13 Colocamos el bloque de escritura de pin en Bucle y lo configuramos para el pin 13. Situamos un bloque de retardo que configuramos a 500 milisegundos. Montamos el programa que vemos en la imagen siguiente: Programa Blink Ya podemos subir el programa a nuestra placa y comprobar el funcionamiento. En la imagen siguiente vemos el resultado en la consola. Consola en el programa Blink An\u00e1lisis del c\u00f3digo \u00b6 Veamos el c\u00f3digo por bloques y linea a l\u00ednea. En la imagen siguiente tenemos relacionados los dos bloques principales con sus l\u00edneas de c\u00f3digo correspondientes. C\u00f3digo del programa Blink A continuaci\u00f3n vemos el c\u00f3digo del bloque Inicializar. void setup() { pinMode(13, OUTPUT); Serial.begin(9600); Serial.flush(); while(Serial.available()>0)Serial.read(); Serial.println(String(\"Inicializaci\u00f3n del proyecto Blink\")); } Establecemos el pin 13 como salida: pinMode(13, OUTPUT); Inicializamos la consola con una velocidad de transmisi\u00f3n de 9600 baudios: Serial.begin(9600); Espera a que la transmisi\u00f3n de datos de salida serie termine: Serial.flush(); Consulta si el n\u00famero de bytes (caracteres) disponibles para lectura desde el puerto serie es mayor que cero: while(Serial.available()>0)Serial.read(); Mandamos el mensaje entrecomillado a la consola: Serial.println(String(\"Inicializaci\u00f3n del proyecto Blink\")); El c\u00f3digo del bloque Bucle es el siguiente: void loop() { digitalWrite(13, HIGH); delay(500); digitalWrite(13, LOW); delay(500); } Establecemos un nivel alto en el pin 13 mediante escritura digital: digitalWrite(13, HIGH); Retardo de medio segundo: delay(500); Establecemos un nivel bajo en el pin 13 mediante escritura digital: digitalWrite(13, LOW); Retardo de medio segundo: delay(500);","title":"Plataforma AB"},{"location":"plataformaAB/#la-plataforma-arduinoblocks","text":"","title":"La plataforma ArduinoBlocks"},{"location":"plataformaAB/#descripcion-del-entorno","text":"Para a\u00f1adir bloques al programa arrastramos desde la barra de herramientas al \u00e1rea de programa, insertando dentro del bloque de inicializaci\u00f3n o de bucle. Pantalla inicial de ArduinoBlocks Si no son funciones, todos los bloques fuera de los dos por defecto son ignorados. ArduinoBlocks genera el c\u00f3digo de Arduino a partir de los bloques. El programa se puede compilar y subir directamente a la placa Arduino gracias a la aplicaci\u00f3n ArduinoBlocks-Connector Descripciones de la pantalla inicial de ArduinoBlocks ArduinoBlocks genera el c\u00f3digo de Arduino a partir de los bloques. Si deseamos ver o descargar el c\u00f3digo podemos realizarlo desde el \u00e1rea de bloques. Ver el c\u00f3digo generado por ArduinoBlocks Si hacemos clic en el bot\u00f3n \"Informaci\u00f3n\" accedemos a toda la informaci\u00f3n del proyecto para cumplimentar o editar y tambi\u00e9n nos permite hacer nuestro proyecto p\u00fablico. Informaci\u00f3n del proyecto Si hacemos clic en el bot\u00f3n archivos accedemos a las opciones que se describen en la imagen siguiente: Archivos del proyecto Es muy interesante subir esquemas de montaje del proyecto realizados por ejemplo con Fritzing. Si hacemos clic en el desplegable de la llave fija se muestra un men\u00fa que nos permite crear s\u00edmbolos de una forma sencilla para diferentes dispositivos de visualizaci\u00f3n y tambi\u00e9n un enlace a informaci\u00f3n sobre RTTTL. Bot\u00f3n herramientas En la imagen siguiente se realiza la descripci\u00f3n del resto de botones e informaci\u00f3n disponible en esta barra. Resto de la barra de botones La imagen a la izquierda del nombre del proyecto es un enlace a una p\u00e1gina de ArduinoBlocks con informaci\u00f3n de la placa usada. Aunque ArduinoBlocks guarda de forma autom\u00e1tica cada cierto tiempo, podemos hacerlo de forma manual pulsando sobre el disquete o sobre el desplegable. La principal utilidad es la de crear un nuevo proyecto a partir del actual pulsando la opci\u00f3n \u201cGuardar como\u201d, lo que abrir\u00e1 el nuevo proyecto creado a partir del primero. Tambi\u00e9n permite generar el proyecto para alumnos, cambiar de tipo de proyecto, o sea cambiar la placa usada dentro de las opciones disponibles y exportar el archivo a nuestro ordenador. La ventana para cambiar el tipo de proyecto se muestra en la imagen siguiente: Opciones para cambiar el tipo de proyecto Si accedemos a Buscar proyectos podremos visualizar los compartidos por otros usuarios, completar las opciones de b\u00fasqueda que nos interesen, ver informaci\u00f3n del proyecto c\u00f3mo los \u201cMe gusta o Like\u201d, ver el n\u00famero de visualizaciones que tiene y visualizarlo nosotros mismos. Opciones de \"Buscaar proyectos\" Al acceder a visualizar un proyecto compartido por otro usuario nos aparecer\u00e1 un bot\u00f3n \u201cimportar a mis proyectos\u201d, que nos permite crear una copia del proyecto en mis proyectos personales para poder modificarlo a nuestro gusto. Tenemos un bot\u00f3n \u201cMe gusta\u201d que nos permite valorar positivamente el trabajo realizado por el usuario. Visualizar un proyecto compartido","title":"Descripci\u00f3n del entorno"},{"location":"plataformaAB/#estructura-de-un-proyecto","text":"Un proyecto Arduino tiene siempre dos estructuras importantes en su interior. Vamos a crear un ejemplo sencillo al que llamaremos Blink escogiendo tipo Arduino UNO. Estructura b\u00e1sica de un proyecto","title":"Estructura de un proyecto"},{"location":"plataformaAB/#blink","text":"Vamos a hacer que al iniciar (o hacer reset) se env\u00ede el mensaje por el puerto serie \u201cInicializaci\u00f3n del proyecto Blink\u201d. Para ello procedemos como se ve en la imagen siguiente. Configuraci\u00f3n de Inicializar para el proyecto Blink","title":"Blink"},{"location":"plataformaAB/#arduinoblocks-connector","text":"Es una aplicaci\u00f3n puente entre la plataforma on-line ArduinoBlocks y el hardware Arduino. La aplicaci\u00f3n recibe el c\u00f3digo generado por ArduinoBlocks, lo compila y lo sube a la placa Arduino. Est\u00e1 disponible para los principales sistemas operativos. En el \u00e1rea de descargas de Arduinoblocks.com se puede obtener la \u00faltima versi\u00f3n y m\u00e1s informaci\u00f3n sobre el proceso de instalaci\u00f3n y configuraci\u00f3n. Connector . Aspecto de la p\u00e1gina de descarga de Connector Para poder grabar nuestro proyecto en la placa Arduino necesitamos tener activado Connector. En la imagen siguiente vemos el icono y el programa en ejecuci\u00f3n. ArduinoBlocks Connector Ya podemos grabar el firmware directamente en nuestra placa a trav\u00e9s de Connector. Para ello conectamos la placa a un puerto USB y hacemos clic en Subir y al cabo de unos instantes veremos algo similar a lo de la imagen siguiente: Blink subido correctamente Ya hemos probado la comunicaci\u00f3n entre la plataforma y nuestro equipo y podemos continuar con el proyecto Blink.","title":"ArduinoBlocks connector"},{"location":"plataformaAB/#continuacion-de-blink","text":"Consultando el pinout de la placa Arduino UNO vemos que en el pin 13 est\u00e1 conectado el LED L, como vemos en la imagen siguiente. Vamos a hacerlo parpadear. LED onboard conectado a D13 Colocamos el bloque de escritura de pin en Bucle y lo configuramos para el pin 13. Situamos un bloque de retardo que configuramos a 500 milisegundos. Montamos el programa que vemos en la imagen siguiente: Programa Blink Ya podemos subir el programa a nuestra placa y comprobar el funcionamiento. En la imagen siguiente vemos el resultado en la consola. Consola en el programa Blink","title":"Continuaci\u00f3n de Blink"},{"location":"plataformaAB/#analisis-del-codigo","text":"Veamos el c\u00f3digo por bloques y linea a l\u00ednea. En la imagen siguiente tenemos relacionados los dos bloques principales con sus l\u00edneas de c\u00f3digo correspondientes. C\u00f3digo del programa Blink A continuaci\u00f3n vemos el c\u00f3digo del bloque Inicializar. void setup() { pinMode(13, OUTPUT); Serial.begin(9600); Serial.flush(); while(Serial.available()>0)Serial.read(); Serial.println(String(\"Inicializaci\u00f3n del proyecto Blink\")); } Establecemos el pin 13 como salida: pinMode(13, OUTPUT); Inicializamos la consola con una velocidad de transmisi\u00f3n de 9600 baudios: Serial.begin(9600); Espera a que la transmisi\u00f3n de datos de salida serie termine: Serial.flush(); Consulta si el n\u00famero de bytes (caracteres) disponibles para lectura desde el puerto serie es mayor que cero: while(Serial.available()>0)Serial.read(); Mandamos el mensaje entrecomillado a la consola: Serial.println(String(\"Inicializaci\u00f3n del proyecto Blink\")); El c\u00f3digo del bloque Bucle es el siguiente: void loop() { digitalWrite(13, HIGH); delay(500); digitalWrite(13, LOW); delay(500); } Establecemos un nivel alto en el pin 13 mediante escritura digital: digitalWrite(13, HIGH); Retardo de medio segundo: delay(500); Establecemos un nivel bajo en el pin 13 mediante escritura digital: digitalWrite(13, LOW); Retardo de medio segundo: delay(500);","title":"An\u00e1lisis del c\u00f3digo"},{"location":"primeros-AB/","text":"Primeros pasos con ArduinoBlocks \u00b6 La pantalla inicial de ArduinoBlocks presenta el siguiente aspecto: Pantalla inicial de ArduinoBlocks Configuraciones \u00b6 Clic sobre la bandera para escoger entre los idiomas disponibles. idioma En las opciones de edici\u00f3n del perfil que incluye la eliminaci\u00f3n de la cuenta, el cambio de contrase\u00f1a y los usuarios gestionados, que b\u00e1sicamente permite crear cuentas para alumnos o centro educativo sin necesidad de correo electr\u00f3nico de los alumnos y los usuarios estar\u00e1n bajo el control de la cuenta de usuario del profesor (o profesores). Los usuarios gestionados tienen algunas limitaciones como no permitir archivos adjuntos en los proyectos o no poder crear proyectos como profesor. Opciones de configuraci\u00f3n Recursos \u00b6 En el men\u00fa desplegable tenemos los recursos disponibles: * ArduinoBlocks Connector * Libros y Documentaci\u00f3n * Librer\u00edas Arduino Recursos ArduinoBlocks Connector \u00b6 Esta aplicaci\u00f3n es necesaria para poder subir nuestros programas a la placa Arduino. Connector Librer\u00edas Arduino \u00b6 Nos permite descargar las librer\u00edas que utiliza la plataforma por si necesitamos usarlas fuera de esta. Librer\u00edas Libros y Documentaci\u00f3n \u00b6 Se trata de un enlace que nos muestra todos los recursos disponibles. Libros y documentaci\u00f3n Resto de opciones \u00b6 Se trata de un enlace que nos muestra todos los recursos disponibles. Resto de opciones Crear proyectos \u00b6 Para iniciar un nuevo proyecto debemos hacer clic en el men\u00fa Proyectos \u2192 Nuevo proyecto o en el bot\u00f3n indicado. Empezar nuevo proyecto Tipo de proyecto: Personal \u00b6 Iniciar un nuevo proyecto que s\u00f3lo ser\u00e1 accesible para el usuario. Posteriormente se puede compartir al resto de la comunidad si se desea. Empezar proyecto personal Tipo de proyecto: Profesor \u00b6 No se inicia un proyecto como tal, sino que se especifican los datos del proyecto y se genera un c\u00f3digo para que los alumnos se puedan suscribir al proyecto. El profesor podr\u00e1 supervisar y valorar los proyectos de sus alumnos. Empezar proyecto profesor Tipo de proyecto: Alumno \u00b6 Permite que nos unamos a un proyecto planteado por el profesor. Nosotros realizaremos el proyecto como si de un proyecto personal se tratara, pero el profesor podr\u00e1 supervisar y valorar nuestro trabajo. Empezar proyecto Alumno Ejemplo: Crear proyecto como Profesor \u00b6 Escogemos opciones. Ejemplo proyecto En la imagen siguiente vemos una serie de apartados que aunque son opcionales es conveniente cumplimentarlos. Ejemplo proyecto Comentarios adicionales y c\u00f3digo del proyecto: Ejemplo proyecto Tenemos creado nuestro primer proyecto. Ejemplo proyecto Si creamos un proyecto como Alumno podemos adherirnos al de profesor. Ejemplo proyecto Y accedemos al entorno de programaci\u00f3n de la plataforma. Ejemplo proyecto Con la opci\u00f3n ver alumnos adheridos accedemos a una ventana como la de la imagen donde podemos ver los proyectos individuales. Ejemplo proyecto","title":"Primeros pasos con AB"},{"location":"primeros-AB/#primeros-pasos-con-arduinoblocks","text":"La pantalla inicial de ArduinoBlocks presenta el siguiente aspecto: Pantalla inicial de ArduinoBlocks","title":"Primeros pasos con ArduinoBlocks"},{"location":"primeros-AB/#configuraciones","text":"Clic sobre la bandera para escoger entre los idiomas disponibles. idioma En las opciones de edici\u00f3n del perfil que incluye la eliminaci\u00f3n de la cuenta, el cambio de contrase\u00f1a y los usuarios gestionados, que b\u00e1sicamente permite crear cuentas para alumnos o centro educativo sin necesidad de correo electr\u00f3nico de los alumnos y los usuarios estar\u00e1n bajo el control de la cuenta de usuario del profesor (o profesores). Los usuarios gestionados tienen algunas limitaciones como no permitir archivos adjuntos en los proyectos o no poder crear proyectos como profesor. Opciones de configuraci\u00f3n","title":"Configuraciones"},{"location":"primeros-AB/#recursos","text":"En el men\u00fa desplegable tenemos los recursos disponibles: * ArduinoBlocks Connector * Libros y Documentaci\u00f3n * Librer\u00edas Arduino Recursos","title":"Recursos"},{"location":"primeros-AB/#arduinoblocks-connector","text":"Esta aplicaci\u00f3n es necesaria para poder subir nuestros programas a la placa Arduino. Connector","title":"ArduinoBlocks Connector"},{"location":"primeros-AB/#librerias-arduino","text":"Nos permite descargar las librer\u00edas que utiliza la plataforma por si necesitamos usarlas fuera de esta. Librer\u00edas","title":"Librer\u00edas Arduino"},{"location":"primeros-AB/#libros-y-documentacion","text":"Se trata de un enlace que nos muestra todos los recursos disponibles. Libros y documentaci\u00f3n","title":"Libros y Documentaci\u00f3n"},{"location":"primeros-AB/#resto-de-opciones","text":"Se trata de un enlace que nos muestra todos los recursos disponibles. Resto de opciones","title":"Resto de opciones"},{"location":"primeros-AB/#crear-proyectos","text":"Para iniciar un nuevo proyecto debemos hacer clic en el men\u00fa Proyectos \u2192 Nuevo proyecto o en el bot\u00f3n indicado. Empezar nuevo proyecto","title":"Crear proyectos"},{"location":"primeros-AB/#tipo-de-proyecto-personal","text":"Iniciar un nuevo proyecto que s\u00f3lo ser\u00e1 accesible para el usuario. Posteriormente se puede compartir al resto de la comunidad si se desea. Empezar proyecto personal","title":"Tipo de proyecto: Personal"},{"location":"primeros-AB/#tipo-de-proyecto-profesor","text":"No se inicia un proyecto como tal, sino que se especifican los datos del proyecto y se genera un c\u00f3digo para que los alumnos se puedan suscribir al proyecto. El profesor podr\u00e1 supervisar y valorar los proyectos de sus alumnos. Empezar proyecto profesor","title":"Tipo de proyecto: Profesor"},{"location":"primeros-AB/#tipo-de-proyecto-alumno","text":"Permite que nos unamos a un proyecto planteado por el profesor. Nosotros realizaremos el proyecto como si de un proyecto personal se tratara, pero el profesor podr\u00e1 supervisar y valorar nuestro trabajo. Empezar proyecto Alumno","title":"Tipo de proyecto: Alumno"},{"location":"primeros-AB/#ejemplo-crear-proyecto-como-profesor","text":"Escogemos opciones. Ejemplo proyecto En la imagen siguiente vemos una serie de apartados que aunque son opcionales es conveniente cumplimentarlos. Ejemplo proyecto Comentarios adicionales y c\u00f3digo del proyecto: Ejemplo proyecto Tenemos creado nuestro primer proyecto. Ejemplo proyecto Si creamos un proyecto como Alumno podemos adherirnos al de profesor. Ejemplo proyecto Y accedemos al entorno de programaci\u00f3n de la plataforma. Ejemplo proyecto Con la opci\u00f3n ver alumnos adheridos accedemos a una ventana como la de la imagen donde podemos ver los proyectos individuales. Ejemplo proyecto","title":"Ejemplo: Crear proyecto como Profesor"},{"location":"turbidez/","text":"Sensor de turbidez \u00b6 Descripci\u00f3n \u00b6 Se trata del KS0414 Keyestudio Turbidity Sensor V1.0 del que disponemos en su wiki de toda la informaci\u00f3n. El funcionamiento del sensor de turbidez est\u00e1 basado en el efecto Tyndall, el cual describe que la dispersi\u00f3n de la luz proyectada en un l\u00edquido con part\u00edculas suspendidas ser\u00e1 mayor cuanto mayor sea el n\u00famero de part\u00edculas. El m\u00f3dulo consta de una placa amplificadora y un sensor, tal y como vemos en la imagen siguiente: Elementos del sensor de turbidez Tiene un rango de detecci\u00f3n de entre 0% y 3.5% (0 y 4550 NTU), con un margen de error de \u00b10.5%. La turbidez se mide en Unidades Nefelom\u00e9tricas de turbidez, o Nephelometric Turbidity Unit (NTU) y el instrumento usado para su medida es el nefel\u00f3metro o turbid\u00edmetro. El sensor dispone de dos modos de operaci\u00f3n o dos tipos de se\u00f1al de salida, anal\u00f3gica y digital. En el modo anal\u00f3gico el c\u00e1lculo de la turbidez del agua se realiza a partir del nivel de tensi\u00f3n medido por el sensor. El modo de operaci\u00f3n se selecciona mediante un interruptor deslizante, siendo la posici\u00f3n A la correspondiente al anal\u00f3gico y D el digital. L\u00f3gicamente la posici\u00f3n del interruptor determina la patilla a la que debemos conectarlo. La resistencia ajustable de color azul permite ajustar la sensibilidad del sensor. Debemos tener muy presente que la parte superior de la sonda no es sumergible. Especificaciones \u00b6 Tensi\u00f3n de alimentaci\u00f3n: 5V DC Consumo: 11mA aproximadamente Rango de detecci\u00f3n: 0% a -3.5%\uff080-4550 NTU\uff09 Temperatura de trabajo: -30 \u2103~ 80 \u2103 Temperatura de almacenamiento\uff1a-10 \u2103 ~ 80 \u2103 Margen de error: \u00b10.5% Peso: 18g Curvas caracter\u00edsticas \u00b6 En la imagen vemos dos gr\u00e1ficas que establecen la relaci\u00f3n entre la turbidez y la tensi\u00f3n medida por el sensor. La de la derecha es m\u00e1s precisa y adem\u00e1s nos da directamente la medida en NTU por lo que ser\u00e1 la que usemos en nuestros ejemplos. Relaciones tensi\u00f3n medida - turbidez Ejemplos de uso del sensor \u00b6 Vamos a ver la aplicaci\u00f3n anal\u00f3gica y digital del sensor y haremos las pruebas sobre un set preparado con tres grados de turbidez a partir de agua del grifo, turbidez media y alta creadas a partir de la disoluci\u00f3n de caf\u00e9 en agua. En la figura siguiente vemos el aspecto. Tres grados de turbidez Lectura digital. Calibraci\u00f3n \u00b6 POSICI\u00d3N DEL INTERRUPTOR: D Vamos a realizar la prueba mas sencilla del sensor que nos servir\u00e1 para su calibraci\u00f3n. Se trata de realizar el siguiente programa: /* ---------------------------------------------------------------------------------------------------------- // Programa...: Lectura-digital.ino // Autor......: @fgcoca (octubre-2019) // Descripci\u00f3n: Visualizaci\u00f3n en el LED onboard (pin 13) del ajuste del potenciometro c\u00f3mo valor digital. // ---------------------------------------------------------------------------------------------------------- */ #define Turbidy_sensor 2 //Conectamos el sensor al pin digital 2 //Poner el interruptor el posici\u00f3n D const int ledPin = 13; //Led onboard void setup() { pinMode(ledPin, OUTPUT); //Configuramos pin 13 como salida pinMode(Turbidy_sensor, INPUT); //Configuramos el pin del sensor de turbidez como entrada } void loop() { if(digitalRead(Turbidy_sensor)==LOW){ //Lectura de la se\u00f1al del sensor digitalWrite(ledPin, HIGH); //Si el sensor indica nivel bajo (LOW) encendemos el LED } else{ digitalWrite(ledPin, LOW); //Si el sensor indica nivel alto (HIGH) encendemos el LED } } El montaje lo vemos en la imagen siguiente: Montaje para lectura digital Introducimos el sensor en agua limpia (si es agua destilada ser\u00e1 m\u00e1s fiable la calibraci\u00f3n) y vamos retocando la posici\u00f3n del potenciometro hasta que el diodo LED asociado al pin 13 se encienda o se apague dependiendo de la posici\u00f3n en la que estuviese. Justo en el momento del cambio debemos girarlo muy suavemente hasta que el LED permanezca apagado. Probamos a introducir el sensor en las muestras turbias para comprobar que el el LED se enciende. Esta ser\u00e1 la posici\u00f3n de calibrado que comprobaremos en el siguiente ejemplo. Puedes descargar el archivo Lectura-digital.ino si te resulta m\u00e1s c\u00f3modo. Lectura b\u00e1sica anal\u00f3gica \u00b6 POSICI\u00d3N DEL INTERRUPTOR: A El siguiente c\u00f3digo escrito en el IDE de Arduino nos permite obtener lecturas b\u00e1sicas del sensor y enviarlas al monitor serie. /* ---------------------------------------------------------------------------------------------------------- // Programa...: Lectura-basica.ino // Autor......: @fgcoca (octubre-2019) // Descripci\u00f3n: Visualizaci\u00f3n del valor de tensi\u00f3n del sensor de turbidez en el terminal serie. // ---------------------------------------------------------------------------------------------------------- */ #define Turbidy_sensor A0 int TurbidySensorValue = 0; float Tension = 0.0; void setup() { Serial.begin(9600); // Velocidad de comunicaci\u00f3n Serial.println(\"Prueba de lectura del sensor de turbidez\"); Serial.println(\"========================================\"); Serial.println(\" \"); Serial.println(\"Lectura analogica\\tTension\"); Serial.println(\"-----------------\\t-------\"); } void loop() { TurbidySensorValue = analogRead(Turbidy_sensor); // Lectura del pin anal\u00f3gico 0 Tension = TurbidySensorValue * (5.0 / 1024.0); // Mapeo de la lectura anal\u00f3gica //Envio de valores y textos al terminal serie Serial.print(TurbidySensorValue); Serial.print(\"\\t\\t\\t\"); Serial.print(Tension); Serial.println(\" V\"); delay(3000); } Puedes descargar el archivo Lectura-basica.ino si te resulta m\u00e1s c\u00f3modo. El montaje es el de la imagen siguiente: Montaje para lectura anal\u00f3gica Los resultados los vemos en la gr\u00e1fica siguiente: Resultados para el montaje para lectura anal\u00f3gica Observamos como la tensi\u00f3n est\u00e1 en un valor de 4.1 \u00b1 0.3V para el ajuste del potenciometro realizado en el ejercicio anterior. Si hemos realizado el ajuste con agua pura y una temperatura comprendida entre 15 y 40 \u00baC tenemos un valor de NTU < 0.5, lo que indica que el ajuste, y por tanto la calibraci\u00f3n son correctos. Lectura en Unidades Nefelom\u00e9tricas de turbidez (NTU) \u00b6 POSICI\u00d3N DEL INTERRUPTOR: A Finalmente vamos a realizar un ejercicio de medida de la turbidez del agua expresando el resultado en unidades nefelom\u00e9tricas. El c\u00f3digo del programa es el siguiente: /* ---------------------------------------------------------------------------------------------------------- // Programa...: Lectura-NTU.ino // Autor......: @fgcoca (octubre-2019) // Descripci\u00f3n: Visualizaci\u00f3n del valor de tensi\u00f3n y de turbidez en NTU en el terminal serie. // ---------------------------------------------------------------------------------------------------------- */ #define Turbidy_sensor A0 float Tension = 0.0; float NTU = 0.0; void setup() { Serial.begin(9600); // Velocidad de comunicaci\u00f3n Serial.println(\"Lectura del sensor de turbidez y expresi\u00f3n del resultado en unidades nefelometricas\"); Serial.println(\"===================================================================================\"); Serial.println(\" \"); Serial.println(\"Tension\\tNTU\"); Serial.println(\"-------\\t---\"); } void loop() { Tension = 0; Tension = analogRead(Turbidy_sensor)/1024*5; // Mapeo de la lectura anal\u00f3gica //Para compensar el ruido producido en el sensor tomamos 500 muestras y obtenemos la media for(int i=0; i<500; i++) { Tension += ((float)analogRead(Turbidy_sensor)/1024)*5; } Tension = Tension/500; Tension = redondeo(Tension,1); //Para ajustarnos a la gr\u00e1fica de la derecha if(Tension < 2.5){ NTU = 3000; }else{ NTU = -1120.4*square(Tension)+5742.3*Tension-4352.9; } //Envio de valores y textos al terminal serie Serial.print(Tension); Serial.print(\" V\"); Serial.print(\"\\t\"); Serial.print(NTU); Serial.println(\" NTU\"); delay(5000); } float redondeo(float p_entera, int p_decimal) { float multiplicador = powf( 10.0f, p_decimal); //redondeo a 2 decimales p_entera = roundf(p_entera * multiplicador) / multiplicador; return p_entera; } Puedes descargar el archivo Lectura-NTU.ino si te resulta m\u00e1s c\u00f3modo. El montaje es el mismo que en el ejercicio anterior. Los resultados de las pruebas sobre el set de medida las vemos en la gr\u00e1fica siguiente: Resultados para el montaje para lectura en NTU","title":"Sensor de turbidez"},{"location":"turbidez/#sensor-de-turbidez","text":"","title":"Sensor de turbidez"},{"location":"turbidez/#descripcion","text":"Se trata del KS0414 Keyestudio Turbidity Sensor V1.0 del que disponemos en su wiki de toda la informaci\u00f3n. El funcionamiento del sensor de turbidez est\u00e1 basado en el efecto Tyndall, el cual describe que la dispersi\u00f3n de la luz proyectada en un l\u00edquido con part\u00edculas suspendidas ser\u00e1 mayor cuanto mayor sea el n\u00famero de part\u00edculas. El m\u00f3dulo consta de una placa amplificadora y un sensor, tal y como vemos en la imagen siguiente: Elementos del sensor de turbidez Tiene un rango de detecci\u00f3n de entre 0% y 3.5% (0 y 4550 NTU), con un margen de error de \u00b10.5%. La turbidez se mide en Unidades Nefelom\u00e9tricas de turbidez, o Nephelometric Turbidity Unit (NTU) y el instrumento usado para su medida es el nefel\u00f3metro o turbid\u00edmetro. El sensor dispone de dos modos de operaci\u00f3n o dos tipos de se\u00f1al de salida, anal\u00f3gica y digital. En el modo anal\u00f3gico el c\u00e1lculo de la turbidez del agua se realiza a partir del nivel de tensi\u00f3n medido por el sensor. El modo de operaci\u00f3n se selecciona mediante un interruptor deslizante, siendo la posici\u00f3n A la correspondiente al anal\u00f3gico y D el digital. L\u00f3gicamente la posici\u00f3n del interruptor determina la patilla a la que debemos conectarlo. La resistencia ajustable de color azul permite ajustar la sensibilidad del sensor. Debemos tener muy presente que la parte superior de la sonda no es sumergible.","title":"Descripci\u00f3n"},{"location":"turbidez/#especificaciones","text":"Tensi\u00f3n de alimentaci\u00f3n: 5V DC Consumo: 11mA aproximadamente Rango de detecci\u00f3n: 0% a -3.5%\uff080-4550 NTU\uff09 Temperatura de trabajo: -30 \u2103~ 80 \u2103 Temperatura de almacenamiento\uff1a-10 \u2103 ~ 80 \u2103 Margen de error: \u00b10.5% Peso: 18g","title":"Especificaciones"},{"location":"turbidez/#curvas-caracteristicas","text":"En la imagen vemos dos gr\u00e1ficas que establecen la relaci\u00f3n entre la turbidez y la tensi\u00f3n medida por el sensor. La de la derecha es m\u00e1s precisa y adem\u00e1s nos da directamente la medida en NTU por lo que ser\u00e1 la que usemos en nuestros ejemplos. Relaciones tensi\u00f3n medida - turbidez","title":"Curvas caracter\u00edsticas"},{"location":"turbidez/#ejemplos-de-uso-del-sensor","text":"Vamos a ver la aplicaci\u00f3n anal\u00f3gica y digital del sensor y haremos las pruebas sobre un set preparado con tres grados de turbidez a partir de agua del grifo, turbidez media y alta creadas a partir de la disoluci\u00f3n de caf\u00e9 en agua. En la figura siguiente vemos el aspecto. Tres grados de turbidez","title":"Ejemplos de uso del sensor"},{"location":"turbidez/#lectura-digital-calibracion","text":"POSICI\u00d3N DEL INTERRUPTOR: D Vamos a realizar la prueba mas sencilla del sensor que nos servir\u00e1 para su calibraci\u00f3n. Se trata de realizar el siguiente programa: /* ---------------------------------------------------------------------------------------------------------- // Programa...: Lectura-digital.ino // Autor......: @fgcoca (octubre-2019) // Descripci\u00f3n: Visualizaci\u00f3n en el LED onboard (pin 13) del ajuste del potenciometro c\u00f3mo valor digital. // ---------------------------------------------------------------------------------------------------------- */ #define Turbidy_sensor 2 //Conectamos el sensor al pin digital 2 //Poner el interruptor el posici\u00f3n D const int ledPin = 13; //Led onboard void setup() { pinMode(ledPin, OUTPUT); //Configuramos pin 13 como salida pinMode(Turbidy_sensor, INPUT); //Configuramos el pin del sensor de turbidez como entrada } void loop() { if(digitalRead(Turbidy_sensor)==LOW){ //Lectura de la se\u00f1al del sensor digitalWrite(ledPin, HIGH); //Si el sensor indica nivel bajo (LOW) encendemos el LED } else{ digitalWrite(ledPin, LOW); //Si el sensor indica nivel alto (HIGH) encendemos el LED } } El montaje lo vemos en la imagen siguiente: Montaje para lectura digital Introducimos el sensor en agua limpia (si es agua destilada ser\u00e1 m\u00e1s fiable la calibraci\u00f3n) y vamos retocando la posici\u00f3n del potenciometro hasta que el diodo LED asociado al pin 13 se encienda o se apague dependiendo de la posici\u00f3n en la que estuviese. Justo en el momento del cambio debemos girarlo muy suavemente hasta que el LED permanezca apagado. Probamos a introducir el sensor en las muestras turbias para comprobar que el el LED se enciende. Esta ser\u00e1 la posici\u00f3n de calibrado que comprobaremos en el siguiente ejemplo. Puedes descargar el archivo Lectura-digital.ino si te resulta m\u00e1s c\u00f3modo.","title":"Lectura digital. Calibraci\u00f3n"},{"location":"turbidez/#lectura-basica-analogica","text":"POSICI\u00d3N DEL INTERRUPTOR: A El siguiente c\u00f3digo escrito en el IDE de Arduino nos permite obtener lecturas b\u00e1sicas del sensor y enviarlas al monitor serie. /* ---------------------------------------------------------------------------------------------------------- // Programa...: Lectura-basica.ino // Autor......: @fgcoca (octubre-2019) // Descripci\u00f3n: Visualizaci\u00f3n del valor de tensi\u00f3n del sensor de turbidez en el terminal serie. // ---------------------------------------------------------------------------------------------------------- */ #define Turbidy_sensor A0 int TurbidySensorValue = 0; float Tension = 0.0; void setup() { Serial.begin(9600); // Velocidad de comunicaci\u00f3n Serial.println(\"Prueba de lectura del sensor de turbidez\"); Serial.println(\"========================================\"); Serial.println(\" \"); Serial.println(\"Lectura analogica\\tTension\"); Serial.println(\"-----------------\\t-------\"); } void loop() { TurbidySensorValue = analogRead(Turbidy_sensor); // Lectura del pin anal\u00f3gico 0 Tension = TurbidySensorValue * (5.0 / 1024.0); // Mapeo de la lectura anal\u00f3gica //Envio de valores y textos al terminal serie Serial.print(TurbidySensorValue); Serial.print(\"\\t\\t\\t\"); Serial.print(Tension); Serial.println(\" V\"); delay(3000); } Puedes descargar el archivo Lectura-basica.ino si te resulta m\u00e1s c\u00f3modo. El montaje es el de la imagen siguiente: Montaje para lectura anal\u00f3gica Los resultados los vemos en la gr\u00e1fica siguiente: Resultados para el montaje para lectura anal\u00f3gica Observamos como la tensi\u00f3n est\u00e1 en un valor de 4.1 \u00b1 0.3V para el ajuste del potenciometro realizado en el ejercicio anterior. Si hemos realizado el ajuste con agua pura y una temperatura comprendida entre 15 y 40 \u00baC tenemos un valor de NTU < 0.5, lo que indica que el ajuste, y por tanto la calibraci\u00f3n son correctos.","title":"Lectura b\u00e1sica anal\u00f3gica"},{"location":"turbidez/#lectura-en-unidades-nefelometricas-de-turbidez-ntu","text":"POSICI\u00d3N DEL INTERRUPTOR: A Finalmente vamos a realizar un ejercicio de medida de la turbidez del agua expresando el resultado en unidades nefelom\u00e9tricas. El c\u00f3digo del programa es el siguiente: /* ---------------------------------------------------------------------------------------------------------- // Programa...: Lectura-NTU.ino // Autor......: @fgcoca (octubre-2019) // Descripci\u00f3n: Visualizaci\u00f3n del valor de tensi\u00f3n y de turbidez en NTU en el terminal serie. // ---------------------------------------------------------------------------------------------------------- */ #define Turbidy_sensor A0 float Tension = 0.0; float NTU = 0.0; void setup() { Serial.begin(9600); // Velocidad de comunicaci\u00f3n Serial.println(\"Lectura del sensor de turbidez y expresi\u00f3n del resultado en unidades nefelometricas\"); Serial.println(\"===================================================================================\"); Serial.println(\" \"); Serial.println(\"Tension\\tNTU\"); Serial.println(\"-------\\t---\"); } void loop() { Tension = 0; Tension = analogRead(Turbidy_sensor)/1024*5; // Mapeo de la lectura anal\u00f3gica //Para compensar el ruido producido en el sensor tomamos 500 muestras y obtenemos la media for(int i=0; i<500; i++) { Tension += ((float)analogRead(Turbidy_sensor)/1024)*5; } Tension = Tension/500; Tension = redondeo(Tension,1); //Para ajustarnos a la gr\u00e1fica de la derecha if(Tension < 2.5){ NTU = 3000; }else{ NTU = -1120.4*square(Tension)+5742.3*Tension-4352.9; } //Envio de valores y textos al terminal serie Serial.print(Tension); Serial.print(\" V\"); Serial.print(\"\\t\"); Serial.print(NTU); Serial.println(\" NTU\"); delay(5000); } float redondeo(float p_entera, int p_decimal) { float multiplicador = powf( 10.0f, p_decimal); //redondeo a 2 decimales p_entera = roundf(p_entera * multiplicador) / multiplicador; return p_entera; } Puedes descargar el archivo Lectura-NTU.ino si te resulta m\u00e1s c\u00f3modo. El montaje es el mismo que en el ejercicio anterior. Los resultados de las pruebas sobre el set de medida las vemos en la gr\u00e1fica siguiente: Resultados para el montaje para lectura en NTU","title":"Lectura en Unidades Nefelom\u00e9tricas de turbidez (NTU)"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Dibujo 3D FreeCAD Sistema operativo: Ubuntu 20.04 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Dibujo 3D FreeCAD Sistema operativo: Ubuntu 20.04 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Web oficial de Keyestudio Wiki de Keyestudio Documentaci\u00f3n de Arduino Documentation, Comunity, Blog Sensor de turbidez DFRobot y TeachMeMicro-TMM","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Web oficial de Keyestudio Wiki de Keyestudio Documentaci\u00f3n de Arduino Documentation, Comunity, Blog Sensor de turbidez DFRobot y TeachMeMicro-TMM","title":"Webgraf\u00eda y bibliograf\u00eda"}]}